[{"title":"Angular依赖包，图片找不到的原因分析及解决方案","url":"/2023/07/12/Angular%E4%BE%9D%E8%B5%96%E5%8C%85%EF%BC%8C%E5%9B%BE%E7%89%87%E6%89%BE%E4%B8%8D%E5%88%B0%E7%9A%84%E5%8E%9F%E5%9B%A0%E5%88%86%E6%9E%90%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/","content":"1、问题描述在Angular开发的依赖包中，若某个组件使用了图片，当集成该依赖包并使用该组件时，会出现图片丢失的问题。\n2、问题原因图片以相对路径形式写到了样式文件中，如background: url(&quot;../../../assets/dobogo/localCpts/name-value/1.png&quot;) center center no-repeat;，打依赖包并集成之后，该组件所处路径已发生变化，意味着该样式所处路径也已经发生变化，此时再以相对路径查找，则直接404\n3、解决方案3.1、方案一\n思路：以行内样式写到html中或js中；\n问题：编码不规范；\n\n3.2、方案二\n思路：采用和Tui框架处理图片相同的方案，即将图片以base64形式打包到代码中；\n问题：使用的图片较少可以，如果较多，则不太合适，图片转base64之后字符太长；\n\n3.3、方案三\n思路：less变量定义相对路径，打依赖包之前替换变量值为.&#x2F;（直接从当前服务路径下查找assets目录），打依赖包之后还原变量值（尽量减少手动维护成本）；\n具体方案：\n\n\n新建变量存储文件variable.less；\n定义变量，如@firstPath: &#x27;../&#x27;;@secondPath: &#x27;../../&#x27;;@thirdPath: &#x27;../../../&#x27;;\n引用变量，如background: url(&quot;@&#123;thirdPath&#125;assets/dobogo/localCpts/name-value/1.png&quot;) center center no-repeat;\n配置打包文件，放到项目根目录即可；\n修改打包命令为：&quot;packagr&quot;: &quot;node variable.imgpath.js step1 &amp;&amp; ng-packagr -p ng-package.json &amp;&amp; node variable.imgpath.js step3&quot;\n打包文件variable.imgpath.js如下：var fs = require(&#x27;fs&#x27;);var args = process.argv.splice(2);var vPath = &#x27;./src/style/variable.less&#x27;; // 根据实际情况调整 var bakPath = &#x27;./src/style/variable.bak.less&#x27;; // 根据实际情况调整 if (args == &#x27;step1&#x27;) &#123;  fs.readFile(vPath, &#x27;utf8&#x27;, function (err, files) &#123;    if (err) &#123; console.log(err); return false; &#125;    fs.writeFile(bakPath, files, &#x27;utf8&#x27;, function (err) &#123;      if (err) &#123; console.log(err); return false; &#125;      console.log(&#x27;less中的图片路径变量备份成功&#x27;);      var result = files.replace(/(..\\/)+/g, &#x27;./&#x27;);      fs.writeFile(vPath, result, &#x27;utf8&#x27;, function (err) &#123;        if (err) &#123; console.log(err); return false; &#125;        console.log(&#x27;less中的图片路径变量替换成功&#x27;);      &#125;);    &#125;);  &#125;);&#125; else if (args == &#x27;step3&#x27;) &#123;  fs.readFile(bakPath, &#x27;utf8&#x27;, function (err, files) &#123;    if (err) &#123; console.log(err); return false; &#125;    fs.writeFile(vPath, files, &#x27;utf8&#x27;, function (err) &#123;      if (err) &#123; console.log(err); return false; &#125;      console.log(&#x27;less中的图片路径变量还原成功&#x27;);      fs.unlink(bakPath, function (err) &#123;        if (err) &#123; console.log(err); return false; &#125;        console.log(&#x27;备份文件删除成功&#x27;);      &#125;);    &#125;);  &#125;);&#125;\n\n","categories":["Angular"]},{"title":"CKEditor5学习开发之路","url":"/2023/01/11/CKEditor5%E5%AD%A6%E4%B9%A0%E5%BC%80%E5%8F%91%E4%B9%8B%E8%B7%AF/","content":"\n在开发富文本编辑器的过程中，遇到了很多问题，这里做下记录与分享。\n\n\n说明：本文中涉及的代码较少，也并非单纯的开发步骤，而是整理的一些思路和问题，如果你是想一步一参考的开发一个Demo，本文并不适合你。\n\n一、背景公司的一款产品中要加入报告功能，简单来讲，就是通过Web浏览器定义word模板、定时任务，服务端根据模板、任务定时生成周报、月报的功能。对于服务端的定时任务、生成周报月报的功能实现，本文不做阐述。本文只介绍Web端的word模板定义的实现思路及遇到的一些问题，对于该功能，除了富文本编辑器基本功能之外，还需支持插入占位符（用于服务端生成word时替换为实际内容）、图表。\n二、技术选型接到需求之后，首先想到的一些成熟的产品，像有道云笔记、腾讯文档、石墨文档、语雀、我来（没使用过，形式好像不太一样）等都有类似功能，但具体是如何实现的呢，不得而知。由于本人之前使用过有道云，所以就想查查有没有相关文章、代码可以参考，没想到还真有。\n\n有道云笔记新版编辑器架构设计（上）\n有道云笔记新版编辑器架构设计（下）\n\n这是有道技术团队分享的架构设计，具有极高的参考价值。看完这两篇文章，本人甚至都有自己开发实现一把的冲动了。奈何考虑到只有我一个人在做这个事情，而且文章虽好，但没有技术细节，实现难度较大，最终只能作罢，只好沿着富文本编辑器的思路继续调研。\n网上关于富文本编辑器的推荐着实不少，推荐几款好用的富文本编辑器、推荐10款常用的富文本编辑器，经过综合对比，最终选定了CKEditor。之所以选CKEditor，一是因为它适配了Angular框架，提供了依赖包@ckeditor/ckeditor5-angular（公司技术栈就是Angular），二是支持从 Word、Excel 和 Google Docs 粘贴。\n三、CKEditor的使用与踩坑对于CKEditor的介绍，这里就不再赘述了，官方文档介绍的更为详细，但目前还没找到中文文档。\n\n不过需要说明的是，能够提前阅读到上述有道技术团队分享的架构设计，也算是比较幸运的，这对于理解CKEditor的架构设计及后面的插件开发，是相当有帮助的。\n\n1、Document EditorCKEditor支持在5种模式下使用：Classic、Balloon、Balloon Block、Inline、Document，而Document恰恰是我们需要的。按照其文档介绍，很容易就能构建出一个Demo。\n2、添加Page break插件由于Document模式默认是不带分页功能的，而Pagination又是收费插件，我们只能退而求其次使用Page break。而当我们按照文档尝试安装并引入该插件时，程序报错了。\ncore.js:7744 ERROR Error: Uncaught (in promise): CKEditorError: ckeditor-duplicated-modules\n对于这个错误，官网也有详细说明，大概意思就是不能在已经构建的包@ckeditor/ckeditor5-build-decoupled-document中再导入新的插件。\n如果只是使用CKEditor提供的现有插件，则可以使用Online Builder来解决上述问题。但正如前文提到的，我们的需求还包括支持插入占位符、图表，因此我们还需继续研究CKEditor如何扩展一个新的插件。\n3、从源代码构建编辑器正如上文提到，当我们想要扩展一个新插件时，就不能使用CKEditor提供的已经构建好的包了[CKEditor提供了5种已构建好的包，对应上述提到的5种使用模式]，而是需要基于源码进行开发构建。可以按照其文档一步步搭建开发环境、开发、构建，而另一种相对比较简单的方式则是直接下载源码，进入packages&#x2F;ckeditor5-build-decoupled-document目录，直接安装依赖、开发、构建。\n其实我一开始的想法是，在一个Angular工程中安装@ckeditor/ckeditor5-angular，然后开发新插件，最后将这个Angular工程打包成一个依赖包提供给产线各部门使用（我们部门的职责之一就是为各部门提供开发套件）。但是在打包代码时程序报错了，具体什么错误记不清了，由于时间关系没有继续研究。TODO: 后面有时间了还得再回来看看。\n四、插件开发好了，准备工作已完成，下面可以进入代码开发阶段了。关于插件开发的入门，可参考这里。\n1、图片上传我们要开发的第一个插件是图片上传插件，确切的说是扩展一个自定义的图片上传适配器。CKEditor默认提供了图片插入功能，但图片并没有提交至服务端，这部分逻辑需要自行实现，按照文档一步步开发即可，没有什么需要特别注意的。\n2、占位符占位符插件也比较简单，直接基于文档中的一个实例改造即可。\n3、插入图表前两个插件的开发，基本上只要是理解了CKEditor的架构设计，并且按照文档的步骤，一般是不会有太多问题的。但是对于插入图表的功能，完全找不到参考，无奈，只能一边梳理思路一边研究官方文档了。\n\n思考一对于图表，我们测试使用的是ECharts。我们知道如果想要实例化一个图表，也即调用它的初始化方法echarts.init(dom?: HTMLDivElement|HTMLCanvasElement)，需要一个Dom元素作为参数，那么我们需要研究的就是在插件中如何能够获取到新创建的Dom了。通过文档中的 Using a React component in a block widget 这个教程，我们发现其在渲染 React component 时，就是获取到插件中新创建的Dom进而渲染组件的。那么这个问题便迎刃而解了。\n\n通过这个问题，需要再次告诫自己，对于这种比较成熟的产品、开发套件、开源库等，一手文档一定是其官方文档，哪怕是英文的，也要仔细研读，不要图省事去网上搜罗别人的博客、技术分享。刚开始的时候，我是各种搜、各种查，但始终没有找到如何获取新创建的Dom的方案，最后还是通过官方文档找到了答案。\n\n\n思考二图表插入之后，如何确定当前选中的是图表元素，进而进行后续的业务操作？相关 API 主要涉及 setCustomProperty、getCustomProperty、getSelectedElement、isWidget，具体含义及用法还是查阅官方文档吧。\n\n思考三图表插入之后，如何调整图表尺寸？开始以为这个问题应该很好解决，因为图片在插入之后，是能够直接拖拽调整大小的，我们只需参考图片插件扩展一个图表 resize 插件即可。但当我们查看图片插件源码时，发现代码量较大，没学习到的 API 也较多，遂暂时放弃了拖拽调整图表大小的想法。那能否通过设定固定尺寸调整图表大小呢？答案是肯定的。这里主要是参考了 @emagtechlabs&#x2F;ckeditor5-classic-image-resize 的代码实现。\n\n思考四实例化多个图表之后，如何区分？这里主要是在定义图表插件的 schema 时带入一个 Id 即可，将来不论是图表的数据填充还是保存模板到服务端，都将通过 Id 来标识唯一的图表实例。\n\n\n五、源码及Demohttps://github.com/DoAutumn/CKEditor5https://doautumn.github.io/CKEditor5/\n","categories":["富文本编辑器"],"tags":["CKEditor5","富文本编辑器"]},{"title":"CentOS安装NodeJS详细教程","url":"/2024/10/13/CentOS%E5%AE%89%E8%A3%85NodeJS%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/","content":"1. 下载\n官网下载链接：http://nodejs.cn/download/\n用wget命令下载wget https://nodejs.org/dist/v16.13.0/node-v16.13.0-linux-x64.tar.xz\n\n2. 解压缩tar -xvf node-v16.13.0-linux-x64.tar.xzmv node-v16.13.0-linux-x64 nodejs\n\n3. 创建软链接ln -s /opt/nodejs/bin/npm /usr/local/bin/ln -s /opt/nodejs/bin/node /usr/local/bin/\n\n4. 验证node -vnpm -v\n\n5. 更换npm源npm config set registry https://registry.npm.taobao.org","categories":["Linux"]},{"title":"Gzip压缩","url":"/2022/08/10/Gzip%E5%8E%8B%E7%BC%A9/","content":"开启Gzip压缩功能后，服务对资源进行Gzip压缩后返回，缩小传输文件大小，提升文件传输效率，减少带宽消耗。\nSpring Boot配置方法#是否开启压缩，默认为falseserver.compression.enabled=true#指定要压缩的MIME typeserver.compression.mime-types=text/*,image/*,application/javascript,application/xml,application/x-font-ttf,application/font-woff\nTomcat配置方法server.xml&lt;Connector port=&quot;8080&quot;  protocol=&quot;HTTP/1.1&quot;  connectionTimeout=&quot;20000&quot;  redirectPort=&quot;8443&quot;  compression=&quot;on&quot;  compressionMinSize=&quot;2048&quot;  noCompressionUserAgents=&quot;gozilla, traviata&quot;  compressableMimeType=&quot;text/*,image/*,application/javascript,application/xml,application/x-font-ttf,application/font-woff&quot;/&gt;","categories":["工具"],"tags":["Gzip","性能优化"]},{"title":"Lerna学习与使用","url":"/2023/09/05/Lerna%E5%AD%A6%E4%B9%A0%E4%B8%8E%E4%BD%BF%E7%94%A8/","content":"一、介绍在学习wangEditor的过程中，了解到Lerna，这里记录下学习与使用过程。\n基本概念就不再赘述了，直接参考这里。在学习过程中也查阅了部分博文，发现有些朋友不是很清楚这个东西是解决什么问题的，这里举例说明下。\n在一个成熟的开发团队中，往往比较注重代码的积累、复用、共享，单就前端来说，一般会积累如下几个开发包：frame、components、charts、utils等等\n\nframe：路由复用策略、路由守卫、HTTP拦截器、国际化、主题。。。\ncomponents、charts：和开源的基础组件库、图表库不同，可能是包含一些它们没有的组件、图表，也可能是一些包含通用业务的组件、图表\nutils：uuid、deepMerge。。。\n\n这些开发包如果是独立的，也不是不可以，只是管理、使用起来比较麻烦，如果相互之前再有依赖关系的话，那就不是比较麻烦了，而是相当麻烦。那么Lerna就是为了解决这个问题的。同时它还能够根据Git提交记录，自动生成版本号、ChangeLog，省去了繁琐的配置步骤，何乐不为呢？\n二、基本使用参考这里的入门，很容易初始化一个Lerna工程。接下来就是创建子包了，可以直接手动创建，比如：\n# 在packages下创建文件夹sub-package$ cd packages$ mkdir sub-package       # 进入文件夹初始包$ cd sub-package$ yarn init\n或者采用lerna指令创建文件夹并初始化，比如：\n$ lerna create sub-package\n在我看来，一般我们不会从零初始化一个Lerna工程，现在3大前端框架、webpack、vite等都提供了脚手架，直接一个命令就可以初始化一个前端工程，对应的tsconfig.json、package.json、README.md、angular.json、vue.config.js等都有了，如果要是从一个空的Lerna工程手动新建这些，着实费劲。所以这里就不过多介绍创建子包之后的操作了，直接进入下一环节。\n三、在Angular工程中使用Lerna@7我们都知道，Angular是提供在一个工程中创建多个Library的功能的，只不过这些Library的发包仍然是独立的，版本号、ChangeLog也是需要手动维护的，并不友好。那么在现有的Angular工程中如何使用Lerna呢？具体步骤如下：\n1、初始化Angular工程$ ng new my-test\n2、新建Library$ cd my-test$ ng g lib my-lib1$ ng g lib my-lib2\n3、初始化Lerna$ lerna init --packages=&quot;projects/*&quot;  // Angular管理子包的目录名默认为projects\n此时会在my-test目录下多出一个lerna.json文件。\n4、调整Library配置Angular默认是将Library打包到工程根目录下的dist目录的，这里做个调整，打包到各自的dist目录：\n// ng-package.json&#123;  &quot;$schema&quot;: &quot;../../node_modules/ng-packagr/ng-package.schema.json&quot;,  &quot;dest&quot;: &quot;./dist&quot;,  // 这里  &quot;lib&quot;: &#123;    &quot;entryFile&quot;: &quot;src/public-api.ts&quot;  &#125;&#125;\n在各自的package.json中添加如下内容（具体package.json详解请参考这里）：\n&#123;  ...  &quot;repository&quot;: &#123;    &quot;type&quot;: &quot;git&quot;,    &quot;url&quot;: &quot;git+https://gitee.com/xxxx/my-test.git&quot;  &#125;,  // 如果不配置，默认就是https://www.npmjs.com/  &quot;publishConfig&quot;: &#123;    &quot;access&quot;: &quot;public&quot;,    &quot;registry&quot;: &quot;http://npm:npm@ip:port/nexus/content/repositories/npm-repo/&quot;  &#125;,  // Lerna默认会将package.json所在目录的所有子内容都发布出去，这里配置只发布dist目录下的内容  &quot;files&quot;: [    &quot;dist&quot;  ],  // 下面的视情况而定  &quot;main&quot;: &quot;dist/bundles/my-lib1.umd.js&quot;,  &quot;module&quot;: &quot;dist/fesm2015/my-lib1.js&quot;,  &quot;es2015&quot;: &quot;dist/fesm2015/my-lib1.js&quot;,  &quot;esm2015&quot;: &quot;dist/esm2015/my-lib1.js&quot;,  &quot;fesm2015&quot;: &quot;dist/fesm2015/my-lib1.js&quot;,  &quot;typings&quot;: &quot;dist/my-lib1.d.ts&quot;&#125;\n5、自动生成版本号和ChangeLog正常开发完代码并git commit之后，\n$ lerna version --conventional-commits\n这将会根据Git commit规范生成版本号和ChangeLog，同时会生成Tag并一起推送到远程Git仓。\n6、发布$ lerna publish from-git --yes\n\n2024-10-29更新关于步骤5、6的特殊说明：\n\n虽然全局安装了lerna，但也不能直接在终端执行上述命令，会报如下错误：lerna ERR! EUNCOMMIT Working tree has uncommitted changes, please commit or remove the following changes before continuing:\n原因是lerna会更新package.json中的版本号和CHANGELOG.md文件，但是坑爹啊有木有，明明是你的机制改动了我本地文件，又说我本地有残留文件，搞不懂为什么会这样\n需要将上述命令放到package.json的scripts中，如下：\"scripts\": {&nbsp;&nbsp;\"version\": \"lerna version --conventional-commits\",&nbsp;&nbsp;\"publish\": \"lerna publish from-git --yes\",},\n然后通过npm run version、npm run publish执行，就不会报错了\n\n\n\n2025-09-30更新如果想要自动生成ChangeLog的同时升级一个大版本，比如从1.x.x升级到2.0.0，了解到的 git commit 规范应该是：\n\n带 ! 标记的类型，如：feat!: 重构用户认证接口，移除旧版 token 验证\n包含 BREAKING CHANGE 的脚注，如：fix: 修复订单计算逻辑修正了折扣计算错误，但改变了返回值格式。BREAKING CHANGE: 订单金额字段从字符串改为数字类型\n但经过验证并不好使（暂时未找到原因），所以只能手动把version脚本改成：\"version\": \"lerna version major --conventional-commits\"\n\n\n\n7、安装依赖如果只想给某个子包安装依赖 或者 子包之间有依赖关系，可通过如下命令实现：\n$ npm install [dependency] -w [package]// dependency可以是子包名称，也可以是开源依赖// package为目标子包名称，是子包的package.json中的name值\n\n\n2024-08-11更新关于步骤7的特殊说明：Lerna@8版本，已经不需要像步骤7那样执行命令了，正常使用npm install\\uninstall即可，当安装的是自己的子包时，也无需添加任何额外的参数，Lerna会自动帮我们处理，并且在node_modules目录下，子包的目录会通过软链接的形式指向实际的代码目录，就像这样\n\n更多细节可参考这里。\n","categories":["工具"],"tags":["Lerna"]},{"title":"Linux部署GitLab","url":"/2025/12/18/Linux%E9%83%A8%E7%BD%B2GitLab/","content":"一、前置条件在安装之前，有两个依赖需要检查下openssh-server和policycoreutils-python\n检查命令如下：\nrpm -qa | grep -i openssh-serverrpm -qa | grep -i policycoreutils-python\n如果输入命令回车后，没有输出任何内容，则需要先安装一下。\n二、下载GitLab下载地址：https://packages.gitlab.com/gitlab/gitlab-ce，注意操作系统和架构。\n三、安装GitLab执行安装命令：\nrpm -ivh gitlab-ce-18.4.6-ce.0.el8.x86_64.rpm\n如果出现如下图所示，说明 GitLab 已经安装成功。\n四、配置https如果不需要https访问，本步骤可跳过。\nsudo mkdir -p /etc/gitlab/sslsudo chmod 755 /etc/gitlab/sslsudo openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout /etc/gitlab/ssl/my-host.internal.key -out /etc/gitlab/ssl/my-host.internal.crt\n命令可直接复制执行。官网地址\n五、配置GitLabvi /etc/gitlab/gitlab.rb\n需要修改的配置有：\n# Update external_url from &quot;http&quot; to &quot;https&quot;external_url &quot;https://ip&quot;# Set Let&#x27;s Encrypt to falseletsencrypt[&#x27;enable&#x27;] = false\n修改完成之后重载配置文件：\ngitlab-ctl reconfigure\n此过程较长，耐心等待，中途不要操作。\n如果出现如下图所示，说明操作成功。\n六、查看管理员密码cat /etc/gitlab/initial_root_password\n/etc/gitlab/initial_root_password是初始化密码的临时存放地，并且在第一次重新加载配置 24 小时后会被清理。\n这个密码要保存好，是 root 用户名的密码，root 用户是最高权限用户。\n七、访问GitLab7.1 可能出现的问题一如果无法访问此网站，首先检查防火墙是否开启，如果开启了，要么关闭防火墙，要么开放 GitLab 端口。\n开放端口：\nsudo firewall-cmd --permanent --add-port=xxxx/tcp\n记得重载防火墙：\nsudo firewall-cmd --reload\n\n7.2 可能出现的问题二如果界面显示 HTTP 502: Waiting for GitLab to boot，（该界面会每 5s 刷新一次），如果一直显示该状态，则需要检查端口是否被占用。\nsudo lsof -i:xxxx# 示例[root@localhost data]# sudo lsof -i :8080COMMAND     PID              USER   FD   TYPE DEVICE SIZE/OFF NODE NAMEjava      42625              root   27u  IPv6 761981      0t0  TCP localhost:http-alt-&gt;localhost:34276 (ESTABLISHED)java      42625              root   48u  IPv6 635861      0t0  TCP *:http-alt (LISTEN)prometheu 61064 gitlab-prometheus   14u  IPv4 762993      0t0  TCP localhost:34276-&gt;localhost:http-alt (ESTABLISHED)\n如果端口被占用，要么关闭进程，要么修改上面/etc/gitlab/gitlab.rb中配置的端口。\n修改端口之后，重新加载 GitLab 配置文件：\nsudo gitlab-ctl reconfigure\n重启 GitLab：\nsudo gitlab-ctl restart","categories":["Linux"],"tags":["GitLab"]},{"title":"CSS 等宽字体","url":"/2024/09/12/CSS_%E7%AD%89%E5%AE%BD%E5%AD%97%E4%BD%93/","content":"在本文中，我们将介绍CSS中的字体族属性font-family: monospace。我们将探讨何时使用等宽字体，以及如何在CSS中实现等宽字体的效果。\n理解等宽字体等宽字体是指每个字符宽度相同的字体。在等宽字体中，每个字符占据相同的空间，无论是宽字符（如W）还是窄字符（如I）。这种特性使得等宽字体在某些情况下非常有用。\n等宽字体常用于编程环境和文字效果展示中，因为字符对齐非常重要。在编写代码时，等宽字体可以确保代码对齐整齐，提高可读性。此外，在展示年份、页码、数字动画时，等宽字体也可以使数字对齐，提高视觉效果。\n在CSS中使用等宽字体要在CSS中使用等宽字体，我们可以使用字体族属性font-family。其中，monospace是指浏览器中默认的等宽字体。通过设置font-family: monospace，我们可以将元素的字体设置为等宽字体。\n但是，CSS中的font-family: monospace其实是引用了一个字体族，而不是具体指定某种字体。不同浏览器和操作系统都可能有不同的默认等宽字体。因此，在实际开发中，我们需要明确指定等宽字体的具体名称。\n自定义等宽字体在CSS中，我们可以使用更具体的等宽字体名称来替代默认的monospace字体。以下是一些常见的等宽字体：\n\nMonaco\nCourier New\nConsolas\nMenlo\n\n.example &#123;  font-family: Monaco, Courier New, Consolas, Menlo, monospace;&#125;\n上面的代码示例中，我们已将等宽字体设定为Monaco。如果Monaco字体不可用，则依次使用Courier New、Consolas和Menlo字体。最后，如果以上字体都不可用，浏览器将使用默认的等宽字体。\n其他网上还有说使用font-feature-settings: &quot;tnum&quot;这里 或 font-variant-numeric: tabular-nums;这里来设置的，但测试并未生效。\n","categories":["CSS"]},{"title":"Mac_手动安装openssl@3","url":"/2024/10/25/Mac-%E6%89%8B%E5%8A%A8%E5%AE%89%E8%A3%85openssl@3/","content":"macOS Big Sur 通过 homebrew 安装 openssl 失败，被嫌弃系统太老。\nI manually installed openssl@3 with the following commands\n\nDownload the latest version from https://www.openssl.org/source/openssl-3.1.1.tar.gz\nUncompress the file with double click and open the terminal. Find the created folder and cd openssl-3.1.1\nContinue withperl ./Configure --prefix=/usr/local --openssldir=/usr/local/openssl no-ssl3 no-ssl3-method no-zlib darwin64-x86_64-cc enable-ec_nistp_64_gcc_128\nmake\nmake test (optional) I passed all tests\nsudo make install MANDIR=/usr/local/Cellar/openssl@3/3.1.1_1/share/man MANSUFFIX=ssl\nopenssl version (optional - verification). It should report OpenSSL 3.1.1 30 May 2023 (Library: OpenSSL 3.1.1 30 May 2023)\nwhich -a openssl (optional).\nbrew link openssl@3\nbrew list (optional) you should see the openssl@3 inside installed packages.\n\n","categories":["Mac"]},{"title":"Mac_Chrome跨域","url":"/2023/02/05/Mac_Chrome%E8%B7%A8%E5%9F%9F/","content":"Mac以允许跨域方式启动Chrome，直接在终端执行以下命令即可：\nopen -n /Applications/Google\\ Chrome.app/ --args --disable-web-security  --user-data-dir=/Users/doautumn/fang/chrome/MyChromeDevUserData\n参考链接\n","categories":["Mac"]},{"title":"Mac_ll命令","url":"/2023/02/22/Mac_ll%E5%91%BD%E4%BB%A4/","content":"Mac默认是不支持ll命令的，为此我们需要做一些配置。\n\n在~/.zshrc文件中加入如下命令：alias ll=&#39;ls -alF&#39;\n\n执行source ~/.zshrc命令，使修改生效。\n\n\n若没有 .zshrc 文件，touch .zshrc新建即可。\n","categories":["Mac"]},{"title":"Mac_tree命令","url":"/2023/03/06/Mac_tree%E5%91%BD%E4%BB%A4/","content":"Tree命令简介Tree是一个递归目录列表命令，使用它可以生成一个深度缩进的目录列表，如下形式：\n├── ngx-planet-master│   ├── docs│   │   ├── api│   │   └── guides│   ├── examples│   │   ├── app1│   │   ├── app2│   │   ├── common│   │   └── portal│   └── packages│       └── planet└── tree-2.1.0    └── doc\n当我们需要详细介绍每个目录的作用时，这将会很有用。\nTree命令安装（源码安装）1、下载安装包2、安装步骤\n\ntar -zxvf tree-2.1.0.tgz\n进入tree-2.1.0目录，修改tree的配置文件Makefile，将其中61行左右的注释去掉，内容参照如下：\n修改完之后，执行命令：make\n使用管理员身份安装，执行命令：sudo cp tree /usr/local/bin/\n测试使用tree命令：tree --version\n\n\n顺便再记录下Linux下安装步骤\n1、yum安装\n\nyum install tree\n\n2、源码安装\n\ntar -zxvf tree-2.1.0.tgz\ncd tree-2.1.0\nmake install\ntree --version\n\n","categories":["Mac"]},{"title":"Mac_全局代理","url":"/2025/08/19/Mac_%E5%85%A8%E5%B1%80%E4%BB%A3%E7%90%86/","content":"目前使用 V2rayU 作为自己的FQiang工具，开启之后，浏览器是能够访问 Google 了，但终端还是不能访问，需要在终端中配置代理。\n直接配置全局代理\nexport all_proxy=http://127.0.0.1:1087  // 这里的IP、Port来自 V2rayU 配置\n\n\n设置完之后，可通过如下命令查看是否生效\ncurl https://google.com\n\n删除代理\nunset all_proxy","categories":["Mac"]},{"title":"Mac_彻底删除应用程序","url":"/2023/01/11/Mac_%E5%BD%BB%E5%BA%95%E5%88%A0%E9%99%A4%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/","content":"不论是通过Finder还是Launchpad卸载应用程序之后，还需要清除应用程序残留的文件，如首选项、支持文件、缓存、隐藏文件等。这些残留文件，目前通过自己使用的情况来看，即使使用CleanMyMac X也无法清除。不过我们可以通过如下方式达到目的：我们只需要在如下目录找到相关目录文件，将其删除即可。\n\n应用程序支持文件：~/Library/Application Support/(App Name)\n首选项：~/Library/Preferences/(App Name)\n资料包：~/Library/Containers/(App Name)\n缓存：~/Library/Caches/(App Name)\n\n如果某些应用在安装时，自动添加到了 设置 &gt; 通用 &gt; 登录项 &gt; 允许在后台，则还需执行如下步骤：\n\ncd /Library/LaunchDaemons/，找到该应用相关的.plist文件，rm -rf xxx删除\ncd /Library/LaunchAgents/，找到该应用相关的.plist文件，rm -rf xxx删除\n\n","categories":["Mac"]},{"title":"Mac_文件添加到Docker并自定义图标","url":"/2024/05/10/Mac_%E6%96%87%E4%BB%B6%E6%B7%BB%E5%8A%A0%E5%88%B0Docker%E5%B9%B6%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9B%BE%E6%A0%87/","content":"有些时候我们需要将文件、目录添加到Docker中实现快速访问，默认地，Mac支持将文件、目录添加到Docker的活动区，非活动区是不能添加的，那如何解决呢？\n\n1.将文件、目录后缀名改为.app即可\n2.将文件、目录拖入Docker之后记得再改回去\n\n自定义图标\n3.右键文件、目录 -&gt; 显示简介\n4.复制一个图标之后，点击弹窗中的图标，直接粘贴即可\n\n设置打开方式\n5.如果是特殊格式的文件，记得选择对应的打开方式\n如.sh，选择终端即可点击就立即执行脚本\n另外在脚本的最后可以添加exit 0命令以结束进程\n还可以设置当shell退出时关闭窗口\n\n\n\n\n","categories":["Mac"]},{"title":"Mac_连接Win10共享的目录","url":"/2023/06/30/Mac_%E8%BF%9E%E6%8E%A5Win10%E5%85%B1%E4%BA%AB%E7%9A%84%E7%9B%AE%E5%BD%95/","content":"废话不多说，直接上步骤1、鼠标右键点击此电脑-管理-本地用户和组-用户\n2、鼠标右击用户-新用户-新建一个用户（实例中用户名为：laowang，密码自己设置），特别注意：用户下次登录时须更改密码前的勾必须去掉\n3、找到想要共享的文件夹，右击-属性-在弹出的对话框中选择共享-点击共享-在下拉菜单中找到新建的用户，添加用户后，可以修改读写权限，然后点击下面的共享\n4、在Mac电脑中，commond + k（连接服务器），输入smb://ip/目录名称即可（ip为Win10电脑IP）\n","categories":["Mac"]},{"title":"Nginx入门","url":"/2025/04/13/Nginx%E5%85%A5%E9%97%A8/","content":"Nginx作为一个高性能的HTTP和反向代理服务器，在Web服务器领域有着广泛的应用。本文将介绍Nginx的基本概念、安装、配置和使用。\n一、Nginx的反向代理首先，看一张关于正向代理和反向代理的图片\n\nNginx 的反向代理是一种常见的网络架构模式，它允许 Nginx 作为中间层，将客户端的请求转发到后端服务器，并将后端服务器的响应返回给客户端。这种模式可以带来许多好处，比如负载均衡、隐藏后端服务器的真实地址、提高性能以及增强安全性。\n1.1 反向代理的基本原理在反向代理模式下，Nginx 充当一个“中介”，客户端并不直接与后端服务器通信，而是通过 Nginx 进行间接访问。具体流程如下：\n\n客户端发送请求：客户端（如浏览器）向 Nginx 发起 HTTP 请求。\nNginx 接收请求：Nginx 收到客户端的请求后，根据配置规则决定如何处理该请求。\n请求转发到后端服务器：Nginx 将请求转发给后端服务器（例如应用服务器、API 服务等）。\n后端服务器处理请求：后端服务器接收到请求后进行处理，并将响应结果返回给 Nginx。\nNginx 返回响应：Nginx 接收到后端服务器的响应后，将其返回给客户端。\n\n在整个过程中，客户端只知道 Nginx 的存在，而不知道后端服务器的具体信息。\n1.2 反向代理的作用1. 负载均衡\n\n当有多个后端服务器时，Nginx 可以将请求分发到不同的服务器上，从而实现负载均衡。这有助于提高系统的可用性和扩展性。\n示例：upstream backend &#123;    server server1.example.com;    server server2.example.com;&#125;server &#123;    location / &#123;        proxy_pass http://backend;    &#125;&#125;\n\n2. 隐藏后端服务器\n\n客户端无法直接访问后端服务器，只能通过 Nginx 访问。这种方式可以保护后端服务器免受直接攻击。\n示例：后端服务器的 IP 地址和端口对客户端完全透明。\n\n3. 缓存\n\nNginx 可以缓存后端服务器的响应内容，减少后端服务器的负载并提高响应速度。\n示例：proxy_cache_path /data/nginx/cache levels=1:2 keys_zone=my_cache:10m max_size=1g inactive=60m use_temp_path=off;server &#123;    location / &#123;        proxy_cache my_cache;        proxy_pass http://backend;    &#125;&#125;\n\n4. SSL终止\n\nNginx 可以处理 HTTPS 请求，解密后再以 HTTP 协议转发给后端服务器。这样可以减轻后端服务器的加密解密负担。\n示例：server &#123;    listen 443 ssl;    server_name example.com;    ssl_certificate /path/to/cert.pem;    ssl_certificate_key /path/to/key.pem;    location / &#123;        proxy_pass http://backend;    &#125;&#125;\n\n5. 统一入口\n\n多个后端服务可以通过一个 Nginx 实例对外提供服务。这样可以简化客户端的访问逻辑。\n示例：server &#123;    location /api/ &#123;        proxy_pass http://api_backend;    &#125;    location /static/ &#123;        proxy_pass http://static_backend;    &#125;&#125;\n\n6. 安全性和访问控制\n\nNginx 可以对请求进行过滤和限制，例如设置速率限制、IP 黑名单等，从而保护后端服务器。\n示例：server &#123;    location / &#123;        limit_req zone=one burst=5;        proxy_pass http://backend;    &#125;&#125;\n\n1.3 配置反向代理的关键指令以下是一些常用的 Nginx 配置指令，用于实现反向代理功能：\n\nproxy_pass\n指定请求转发的目标地址。\n示例：location / &#123;    proxy_pass http://backend_server;&#125;\n\n\nproxy_set_header\n设置转发请求时附加的 HTTP 头部信息，通常用于传递客户端的真实 IP 地址等信息。\n示例：proxy_set_header Host $host;proxy_set_header X-Real-IP $remote_addr;proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n\n\nupstream\n定义一组后端服务器，支持负载均衡。\n示例：upstream backend &#123;    server 192.168.1.101;    server 192.168.1.102;&#125;\n\n\nproxy_cache\n启用缓存功能，提升性能。\n示例：proxy_cache_path /data/nginx/cache levels=1:2 keys_zone=my_cache:10m;proxy_cache my_cache;\n\n\nproxy_read_timeout 和 proxy_connect_timeout\n设置超时时间，避免长时间等待。\n示例：proxy_read_timeout 60s;proxy_connect_timeout 10s;\n\n\n\n1.4 root 和 alias 区别root 和 alias 指令都用于指定服务器静态资源文件的路径，例如 HTML 文件、视频、图片文件等。虽然它们的使用方法比较相似，但有一些关键区别，容易导致混淆。\n\nrootroot 指令用于设置请求的根目录。它通常定义在 server 或 location 块中。root 指令会将请求的 URI 附加到指定的根目录路径后面。例如：location /images/ &#123;   root /var/www;&#125;\n在这个例子中，请求 /images/example.jpg 将会映射到文件路径 /var/www/images/example.jpg(实际路径是 root值 + location值)。\naliasalias 指令用于将请求的 URI 映射到指定的目录。与 root 不同，alias 指令会将请求的 URI 替换为指定的目录路径。例如：location /images/ &#123;   alias /var/www/images/;&#125;\n在这个例子中，请求 /images/example.jpg 同样将会映射到文件路径 /var/www/images/example.jpg(实际路径就是 alias值)。\n\n二、Nginx的安装2.1 官网下载2.2 安装由于我是在极空间的 Docker 中安装的，遇到的最大问题就是缺各种依赖，总结下来需要安装的依赖包括：\nyum -y install gcc gcc-c++ automake autoconf libtool makeyum -y install zlib zlib-devel openssl openssl-devel pcre pcre-devel\n\n\n检测编译环境并配置安装规则\n\n// 解压文件tar -zxvf nginx-1.26.3.tar.gz// 进入目录cd nginx-1.26.3// 检测编译环境并配置安装规则（默认路径一般不去修改）./configure\n\n过程如下：\n出现如下信息表示成功：\n\n编译安装\n\nmake &amp;&amp; make install\n\n三、Nginx常用命令cd /usr/local/nginx/sbin/./nginx  启动./nginx -s stop  停止./nginx -s quit  安全退出./nginx -s reload  重新加载配置文件  如果我们修改了配置文件，就需要重新加载。ps aux|grep nginx  查看nginx进程\n","categories":["工具"],"tags":["Nginx"]},{"title":"Mac_电源控制","url":"/2023/09/14/Mac_%E7%94%B5%E6%BA%90%E6%8E%A7%E5%88%B6/","content":"Mac电脑默认提供了优化电池充电功能，但没用明白，新电脑拿到手之后，不知道什么样的充电频次才能让它暂缓充电至80%。\n因此需要借助三方App来实现对电池充电的控制，网上提到较多的是 AlDente 这款软件，但它是收费的。\n这里推荐一个开源软件（不适用Inter芯片的Mac），可以选择安装带界面的版本或终端版本。我本人用的是终端版本，带界面的版本会在菜单栏另外显示一个电池图标，我不需要。\n终端版本的安装命令如下：\ncurl -s https://raw.githubusercontent.com/actuallymentor/battery/main/setup.sh | bash\n\n一般来讲是安装不成功的，那么可以直接下载源码，在源码目录路径下执行./setup.sh。\n安装完之后通过在终端中运行下面的命令来开启限制充电，当电池电量达到80%时就停止充电。更多相关的命令使用 –help 查看。\nbattery maintain 80\n\n\n2025-10-10更新升级到 macOS Tahoe 26 之后，battery不起作用了，很多人反馈了 issues，也没见作者有回复，在众多 issues 中，有人推荐了batt，试了一下效果还不错。\n\nInstallation Script\nbash &lt;(curl -fsSL https://github.com/charlie0129/batt/raw/master/hack/install.sh)\n\nHelp\ndoautumn@Mac ~ % batt helpbatt is a tool to control battery charging on Apple Silicon MacBooks.Website: https://github.com/charlie0129/battUsage:  batt [command]Basic:  adapter                    Enable or disable power input  disable                    Disable batt  limit                      Set upper charge limit  status                     Get the current status of battAdvanced:  disable-charging-pre-sleep Set whether to disable charging before sleep if charge limit is enabled  lower-limit-delta          Set the delta between lower and upper charge limit  magsafe-led                Control MagSafe LED according to battery charging status  prevent-idle-sleep         Set whether to prevent idle sleep during a charging session  prevent-system-sleep       Set whether to prevent system sleep during a charging session (experimental)Installation:  install                    Install batt (system-wide)  uninstall                  Uninstall batt (system-wide)Additional Commands:  completion                 Generate the autocompletion script for the specified shell  gui                        Start the batt GUI (debug)  help                       Help about any command  version                    Print versionFlags:      --config string          config file path (default &quot;/etc/batt.json&quot;)      --daemon-socket string   batt daemon unix socket path (default &quot;/var/run/batt.sock&quot;)  -h, --help                   help for batt  -l, --log-level string       log level (trace, debug, info, warn, error, fatal, panic) (default &quot;info&quot;)Use &quot;batt [command] --help&quot; for more information about a command.\n\n","categories":["Mac"]},{"title":"Puppeteer学习与使用","url":"/2023/09/08/Puppeteer%E5%AD%A6%E4%B9%A0%E4%B8%8E%E4%BD%BF%E7%94%A8/","content":"\n对Puppeteer的学习并没有深入，只是项目中用到了，这里记录下使用过程中的几个问题\n\n一、背景项目需求还是和富文本编辑器、报告有关，具体流程可描述为：在界面通过富文本编辑器编辑了一篇周报，周报中包含一些配置了如何获取数据的统计数值占位符、图表，将这样一串富文本提交给服务端并设置好定时任务，服务端周期性的获取最新数据替换占位符，填充到图表并渲染截图，最后生成PDF格式的报告。\n对于服务端如何渲染图表并截图，记录下实现方案。\n二、技术方案与选型如果图表使用ECharts的话，它本身就是支持服务端渲染的，但很可惜，我们有些图表是自己开发的，使用Dom实现的，比如下面这样一个图表，用数据驱动*ngFor反而更简单，当然问题就是不能适配服务端渲染。\n好在无头浏览器的实践方案能够解决这个问题。\n由于另一个团队有过相关经验，他们使用的是PhantomJS，所以一开始也是奔着这个去调研的。后来才发现，它已经停更了，所以果断放弃，转向了Puppeteer。\n三、问题记录1、跳过下载浏览器有两种方式：\nnpm i puppeteer-core或npm i puppeteer --PUPPETEER_SKIP_DOWNLOAD  // 这种方式是文档中没提到的\n\n2、指定浏览器跳过下载浏览器之后，如何指定已经安装的浏览器呢？通过chrome://version可查询Chrome的可执行文件路径\nconst browser = await puppeteer.launch(&#123;executablePath: &#x27;上图中的可执行文件路径&#x27;&#125;);\n\n3、打开本地HTML文件await page.goto(&#x27;file:///Users/xxxx/Desktop/puppeteer/index.html&#x27;);\n\n4、访问window// 在puppeteer中也是可以直接访问window对象的，比如在index.html中给window设置了变量或方法，在puppeteer中是可以直接调用的await page.evaluate(() =&gt; &#123;  console.log(window.testFun());&#125;);\n\n5、window监听事件// 如果想使用window监听打开的页面中派发的事件，则应该这样await page.evaluateOnNewDocument(() =&gt; &#123;  window.addEventListener(&#x27;eventName&#x27;, () =&gt; &#123;    // your code  &#125;);&#125;);","categories":["其他"],"tags":["Puppeteer","无头浏览器"]},{"title":"Vue3入门","url":"/2023/04/23/Vue3%E5%85%A5%E9%97%A8/","content":"虽然之前整理过使用 Vite 构建 Vue3 组件库、Lerna 学习与使用，但都过于简单，对于 Vue 的基本概念、语法等知之甚少，也基本没用过 Vite，诸如以下问题均不甚了解：\n\nSFC 是什么？\nHooks 又是什么？\n如何理解 Composition API？\n如何实现组件继承？\n如何自定义指令？\n如何自定义结构型指令？\n自定义的指令、组件，是如何实现完整引入和手动导入两种方式的？\nVue3 中的依赖注入和 Angular 中的有什么区别？\n使用 Vite + Vue3 + TypeScript，如何在一个工程中同时构建多个依赖包？如何组织目录更合理？\n依赖包如何自动生成 .d.ts 声明文件？\n如何实现国际化？\n如何动态创建组件？\n在开发依赖包的过程中，如何更优雅的编写帮助文档？\n\n一、SFC一个 Vue 单文件组件 (SFC)，通常使用 *.vue 作为文件扩展名，它是一种使用了类似 HTML 语法的自定义文件格式，用于定义 Vue 组件。一个 Vue 单文件组件在语法上是兼容 HTML 的。\n每一个 *.vue 文件都由三种顶层语言块构成：&lt;template&gt;、&lt;script&gt; 和 &lt;style&gt;，以及一些其他的自定义块：\n&lt;template&gt;  &lt;div class=&quot;example&quot;&gt;&#123;&#123; msg &#125;&#125;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  data() &#123;    return &#123;      msg: &#x27;Hello world!&#x27;    &#125;  &#125;&#125;&lt;/script&gt;&lt;style&gt;.example &#123;  color: red;&#125;&lt;/style&gt;&lt;custom1&gt;  This could be e.g. documentation for the component.&lt;/custom1&gt;\n\n二、HooksVue3 官方文档并没有对 Hooks 做明确定义，却无处不在在使用这个技巧，很多开源项目也在用这个技巧，这里有一些大佬的分享：\n\nVue3中的Hooks详解\n理解Vue3中的hooks\nVue3必学技巧-自定义Hooks-让写Vue3更畅快\n\n其中，我觉得这个解释是最清晰易懂的：\n\n一般来说，我们开发中会自动抽象出逻辑函数放在utils中，utils中放的纯逻辑，不存在属于组件的东西，例如methods中定义的纯函数等。而hooks就是在utils的基础上再包一层组件级别的东西(钩子函数等)\nhooks和utils的区别： hooks中如果涉及到ref,reactive,computed这些api的数据，那这些数据是具有响应式的，而utils只是单纯提取公共方法就不具备响应式，因此可以把hook理解为加入vue3 api的共通方法\n\n三、Composition API组合式 API (Composition API) 是一系列 API 的集合，使我们可以使用函数而不是声明选项的方式书写 Vue 组件。它是一个概括性的术语，涵盖了以下方面的 API：\n\n响应式 API：例如 ref() 和 reactive()，使我们可以直接创建响应式状态、计算属性和侦听器。\n生命周期钩子：例如 onMounted() 和 onUnmounted()，使我们可以在组件各个生命周期阶段添加逻辑。\n依赖注入：例如 provide() 和 inject()，使我们可以在使用响应式 API 时，利用 Vue 的依赖注入系统。\n组合式函数\n组合式 API 常见问答\n\n四、如何实现组件继承？对于一位习惯使用面向对象编程语言的开发者而言，继承被视为一种自然而然的设计模式，Angular 对这一模式的支持更是加深了这种印象，使我一度认为继承是一种理所当然的选择。然而，Vue 并不特别推崇这种方案。在 Vue3 中，它更倾向于推荐使用 Composition API 和可复用的逻辑来实现组件间的复用，这导致我在刚开始的开发过程中着实不是很适应。\n1、Composition API 的优势\n更好的可测试性：Composition API 的逻辑更容易被拆分成独立的单元进行测试。\n更清晰的代码结构：每个组合函数负责一部分特定的逻辑，使代码更易于理解和维护。\n更好的可复用性：逻辑可以通过组合函数在多个组件之间共享。\n\n2、面向对象继承与 Composition API 的对比在面向对象继承中，可以直接重写方法，这通常意味着：\n\n简洁性：可以直接覆盖方法实现。\n继承性：子类可以继承父类的所有属性和方法。\n多态性：可以利用多态性来实现不同的行为。\n\n然而，面向对象继承也有一些缺点：\n\n紧耦合：类之间的关系紧密，修改一个类可能会影响到其他依赖它的类。\n难以复用：类的逻辑通常与类本身绑定，不易于在不同场景下复用。\n难以调试和测试：较大的类可能会包含许多逻辑，使得调试和测试变得复杂。\n\n五、如何自定义指令？在 &lt;script setup&gt; 中，任何以 v 开头的驼峰式命名的变量都可以被用作一个自定义指令。比如下面的例子，vFocus 即可以在模板中以 v-focus 的形式使用。\n&lt;script setup&gt;  const vFocus = &#123;    mounted: (el) =&gt; el.focus()  &#125;&lt;/script&gt;&lt;template&gt;  &lt;input v-focus /&gt;&lt;/template&gt;\n一般来讲，我们通常会单独封装一些通用指令，而很少会在单个 Vue 组件中自定义指令，比如我们可以这样做：\nexport const vFocus = &#123;  mounted: (el) =&gt; el.focus()&#125;\n使用该指令时，我们可以手动导入使用它：\nimport &#123; vFocus &#125; from &#x27;xxx&#x27;\n也可以将其全局注册到应用层级：\nconst app = createApp(&#123;&#125;)// 使 v-focus 在所有组件中都可用app.directive(&#x27;focus&#x27;, vFocus)\n而当我们在依赖包中自定义了 N 多个指令时，我们一般会采用插件的方式为每一个指令提供一个 install 方法，然后全局安装插件：\n\n首先定义一个为指令挂载 install 的通用方法：export const withInstallDirective = &lt;T extends Directive&gt;(  directive: T,  name: string) =&gt; &#123;  ;(directive as SFCWithInstall&lt;T&gt;).install = (app: App): void =&gt; &#123;    app.directive(name, directive)  &#125;  return directive as SFCWithInstall&lt;T&gt;&#125;\n然后每一个指令使用该方法挂载 install：export const ElFocus = withInstallDirective(vFocus, &#x27;focus&#x27;)export default ElFocus\n最后在依赖包的 index.ts 中安装插件，同时将依赖包本身也作为插件挂载上 install：import &#123; ElFocus &#125; from &#x27;xxx&#x27;const plugins: Plugin[] = [  ElFocus,  ...]export default &#123;  install(app: App) &#123;    plugins.forEach(c =&gt; app.use(c)) // app.use() 方法会自动调用插件的 install() 方法  &#125;&#125;\n\n上面借助插件的设计思路同时介绍了自定义的指令、组件如何实现完整引入和手动导入两种方式。在 Angular 中，没有完整引入的概念，因此这里的插件、install、use需要稍微理解一下。\n六、如何自定义结构型指令？在 Vue 中自定义结构型指令比在 Angular 中要简单的多，直接通过 parentNode.appendChild()、parentNode.removeChild() 实现即可。\n// 假设这里有一个权限检查函数function checkAuth(value) &#123;  // 实现权限检查逻辑  return true; // 返回布尔值表示用户是否有权限&#125;// 定义自定义指令export const vAuth = &#123;  mounted(el, binding) &#123;    if (!checkAuth(binding.value)) &#123;      el.parentNode.removeChild(el); // 移除 DOM 节点    &#125;  &#125;,  beforeUpdate(el, binding) &#123;    if (!checkAuth(binding.value)) &#123;      el.parentNode.removeChild(el); // 移除 DOM 节点    &#125; else if (!el.parentNode) &#123;      el.parentNode.appendChild(el); // 如果已经被移除，则重新添加    &#125;  &#125;,  updated(el, binding) &#123;    if (checkAuth(binding.value) &amp;&amp; !el.parentNode) &#123;      el.parentNode.appendChild(el); // 如果已经被移除，则重新添加    &#125;  &#125;&#125;\n\n七、Vue3 中的依赖注入和 Angular 中的有什么区别？链接：https://cn.vuejs.org/guide/components/provide-inject.html在我看来，其实没什么区别，只是写法的区别。在 Angular 中，先是在类的元数据中标记这是可被注入的，然后在 NgModule 的元数据的 providers 中提供，最后直接在其它类的构造函数中注入即可：\n// 标记是可被注入的@Injectable()export class TestService &#123;&#125;// Provide 提供@NgModule(&#123;  ...,  providers: [TestService]&#125;)// 直接注入使用export class OtherClass &#123;  constructor(private ser: TestService) &#123;&#125;&#125;\n而在 Vue 中，没有元数据的概念，没有可被注入的概念，直接提供、直接注入：\n&lt;script setup&gt;import &#123; provide &#125; from &#x27;vue&#x27;provide(/* 注入名 */ &#x27;message&#x27;, /* 值 */ &#x27;hello!&#x27;)&lt;/script&gt;\n&lt;script setup&gt;import &#123; inject &#125; from &#x27;vue&#x27;const message = inject(&#x27;message&#x27;)&lt;/script&gt;\n当然也是可以全局注入的，具体参考上面链接中的官方文档。\n八、使用 Vite + Vue3 + TypeScript，如何在一个工程中同时构建多个依赖包？如何组织目录更合理？如果只是开发一个组件库，那么完全可以参考 Element Plus 的目录结构和打包方式，或者也可以参考手把手带你手搓组件库这样的视频教程，他其实也是参考了 Element Plus，只是不需要自己翻 Element Plus 的源码了。\n虽然 Element Plus 是一个单一的组件库，但其内部仍然是拆分了多个子包，通过 pnpm 管理多个子包。pnpm 内置了对单一存储库（也称为多包存储库、多项目存储库或单体存储库）的支持， 你可以创建一个 workspace 以将多个项目合并到一个仓库中。但我不喜欢用 pnpm，因为我的 Angular 工程，使用 npm 下载依赖包运行程序没问题，使用 pnpm 下载运行就报错，当然是相同版本的 node 和相同的 package.json，我也懒得去研究了，还是继续使用 Lerna 来实现多包管理。\n需求层面，我并不只是要实现单一的组件库，而是要包含 Lerna 学习与使用中已经提到过的 frame、components、charts、compoxes、utils 等。废话不多说，直接开始吧。\n1、初始化 Vue 工程我还是习惯 Angular 的设计方案，它是区分应用程序 (application) 和库 (lib) 的，可以通过 cli 直接初始化一个应用程序项目 或 库项目，当然 Vue 也是区分的，只是在打包的时候使用不同的 Vite 配置，需要手动配置。在 Angular 中一般都是先创建一个应用程序，再通过 ng g lib library[name] [options] 命令创建一个库项目。Vue 没有这样的命令，只能手动创建。\n通过 npm create vite@latest my-vue-app -- --template vue-ts 初始化一个工程之后，手动创建 packages/frame、packages/components、packages/charts、packages/compoxes、packages/utils 目录，并在各自目录下创建一个 src 目录和 index.ts、package.json、vite.config.ts 3个文件，此时整个工程目录是这样：\n每一个子包都需要单独打包，所以每一个目录下都有一个 vite.config.ts 文件。\n2、初始化 Lerna在 my-vue-app 目录下直接执行 npx lerna init --packages=&quot;packages/*&quot; 即可，它会创建一个 lerna.json 文件，并安装 lerna 依赖。注意： 上面这个命令并不会在 package.json 中插入 workspaces 属性，需要我们手动添加：\n&#123;  ...  &quot;workspaces&quot;: [    &quot;packages/*&quot;  ]&#125;\n接下来就可以直接无视 Lerna 了，我们还是正常使用 npm install\\uninstall，当安装的是自己的子包时，也无需添加任何额外的参数，Lerna 会自动帮我们处理，并且在 node_modules 目录下，子包的目录会通过软链接的形式指向实际的代码目录，就像这样：\n3、配置 vite.config.ts可以像官方文档推荐的库模式那样只配置一个 vite.config.ts 文件，也可以像教程项目打包一样配置两个文件 vite.es.config.ts 和 vite.umd.config.ts。\n4、配置 package.json除了官方文档推荐的内容之外，\n&#123;  &quot;name&quot;: &quot;my-lib&quot;,  &quot;type&quot;: &quot;module&quot;,  &quot;files&quot;: [&quot;dist&quot;],  &quot;main&quot;: &quot;./dist/my-lib.umd.cjs&quot;,  &quot;module&quot;: &quot;./dist/my-lib.js&quot;,  &quot;exports&quot;: &#123;    &quot;.&quot;: &#123;      &quot;import&quot;: &quot;./dist/my-lib.js&quot;,      &quot;require&quot;: &quot;./dist/my-lib.umd.cjs&quot;    &#125;  &#125;&#125;\n还有必要加入其它信息：version、description、publishConfig 等。\n&#123;  &quot;name&quot;: &quot;my-lib&quot;,  &quot;version&quot;: &quot;1.0.0&quot;,  &quot;description&quot;: &quot;my lib&quot;,  &quot;type&quot;: &quot;module&quot;,  &quot;publishConfig&quot;: &#123;  // 如果有必要的话    &quot;access&quot;: &quot;publish&quot;,    &quot;registry&quot;: &quot;&quot;  &#125;,  &quot;files&quot;: [&quot;dist&quot;],  &quot;main&quot;: &quot;./dist/my-lib.umd.cjs&quot;,  &quot;module&quot;: &quot;./dist/my-lib.js&quot;,  &quot;exports&quot;: &#123;    &quot;.&quot;: &#123;      &quot;import&quot;: &quot;./dist/my-lib.js&quot;,      &quot;require&quot;: &quot;./dist/my-lib.umd.cjs&quot;    &#125;  &#125;&#125;\n5、打包我们可以切换到各自目录下执行 vite build 目录，因为当以命令行方式运行 vite 时，Vite 会自动解析当前目录下名为 vite.config.ts 的文件，也可以显式地通过 --config 命令行选项指定一个配置文件（相对于 cwd 路径进行解析），比如这样，直接在根目录的 package.json 中配置打包脚本，并指定 vite.config.ts：\n&#123;  &quot;scripts&quot;: &#123;    &quot;dev&quot;: &quot;vite&quot;,    &quot;build&quot;: &quot;vite build&quot;,    &quot;build:lib&quot;: &quot;npm run build:utils &amp;&amp; npm run build:components &amp;&amp; npm run build:compoxes &amp;&amp; npm run build:charts &amp;&amp; npm run build:frame&quot;,    &quot;build:charts&quot;: &quot;vite build --config packages/charts/vite.config.ts&quot;,    &quot;build:components&quot;: &quot;vite build --config packages/components/vite.config.ts&quot;,    &quot;build:compoxes&quot;: &quot;vite build --config packages/compoxes/vite.config.ts&quot;,    &quot;build:frame&quot;: &quot;vite build --config packages/frame/vite.config.ts&quot;,    &quot;build:utils&quot;: &quot;vite build --config packages/utils/vite.config.ts&quot;  &#125;&#125;\n\n九、依赖包如何自动生成 .d.ts 声明文件？上面经过一些列的配置，已经能够正常打包了，但还不能自动生成 .d.ts 声明文件，这在使用依赖包时并不友好。我们可以直接通过 vite-plugin-dts 插件自动生成声明文件，但过程中也遇到了一些问题，需要记录下。\n1、安装并配置 vite-plugin-dts 插件npm i vite-plugin-dts -D\n// vite.config.tsimport &#123; resolve &#125; from &#x27;path&#x27;import &#123; defineConfig &#125; from &#x27;vite&#x27;import vue from &#x27;@vitejs/plugin-vue&#x27;import dts from &#x27;vite-plugin-dts&#x27;export default defineConfig(&#123;  plugins: [vue(), dts()],  build: &#123;    lib: &#123;      entry: resolve(__dirname, &#x27;lib/main.js&#x27;),      name: &#x27;MyLib&#x27;,      // the proper extensions will be added      fileName: &#x27;my-lib&#x27;    &#125;,    rollupOptions: &#123;      // 确保外部化处理那些你不想打包进库的依赖      external: [&#x27;vue&#x27;],      output: &#123;        // 在 UMD 构建模式下为这些外部化的依赖提供一个全局变量        globals: &#123;          vue: &#x27;Vue&#x27;        &#125;      &#125;    &#125;  &#125;&#125;)\n2、打包此时直接打包，如果使用的是 &quot;vite-plugin-dts&quot;: &quot;^4.0.2&quot; 版本，并没有自动生成声明文件；如果使用的是 &quot;vite-plugin-dts&quot;: &quot;^3.9.1&quot; 版本，还会报错：\nindex.ts:1:15 - error TS2792: Cannot find module &#x27;./src/vue&#x27;. Did you mean to set the &#x27;moduleResolution&#x27; option to &#x27;nodenext&#x27;, or to add aliases to the &#x27;paths&#x27; option?\n经过前端 Vite 项目使用 vite-plugin-dts 打包输出.d.ts文件，分析处理踩坑的解释，应该就是 tsconfig.json 的原因。\n所以我们可以在各子包目录下新建一个 tsconfig.build.json 文件，内容直接复制 tsconfig.app.json 中的内容，然后再改下 include 路径即可。\n&#123;  ...  &quot;include&quot;: [    &quot;./index.ts&quot;,    &quot;./src/**/*.ts&quot;,    &quot;./src/**/*.vue&quot;  ]&#125;\n然后再将 tsconfig.build.json 配置到 vite-plugin-dts 插件中就能够自动生成声明文件了。\n// vite.config.tsimport &#123; resolve &#125; from &#x27;path&#x27;import &#123; defineConfig &#125; from &#x27;vite&#x27;import vue from &#x27;@vitejs/plugin-vue&#x27;import dts from &#x27;vite-plugin-dts&#x27;export default defineConfig(&#123;  plugins: [vue(), dts(&#123; tsconfigPath: &#x27;./tsconfig.build.json&#x27;, outDir: &#x27;./dist/types&#x27; &#125;)],  build: &#123;    lib: &#123;      entry: resolve(__dirname, &#x27;lib/main.js&#x27;),      name: &#x27;MyLib&#x27;,      // the proper extensions will be added      fileName: &#x27;my-lib&#x27;    &#125;,    rollupOptions: &#123;      // 确保外部化处理那些你不想打包进库的依赖      external: [&#x27;vue&#x27;],      output: &#123;        // 在 UMD 构建模式下为这些外部化的依赖提供一个全局变量        globals: &#123;          vue: &#x27;Vue&#x27;        &#125;      &#125;    &#125;  &#125;&#125;)\n最后不要忘了在 package.json 中添加类型声明文件路径。\n&#123;  &quot;name&quot;: &quot;my-lib&quot;,  &quot;version&quot;: &quot;1.0.0&quot;,  &quot;description&quot;: &quot;my lib&quot;,  &quot;type&quot;: &quot;module&quot;,  &quot;publishConfig&quot;: &#123;  // 如果有必要的话    &quot;access&quot;: &quot;publish&quot;,    &quot;registry&quot;: &quot;&quot;  &#125;,  &quot;files&quot;: [&quot;dist&quot;],  &quot;types&quot;: &quot;./dist/types/index.d.ts&quot;,  &quot;main&quot;: &quot;./dist/my-lib.umd.cjs&quot;,  &quot;module&quot;: &quot;./dist/my-lib.js&quot;,  &quot;exports&quot;: &#123;    &quot;.&quot;: &#123;      &quot;types&quot;: &quot;./dist/types/index.d.ts&quot;,      &quot;import&quot;: &quot;./dist/my-lib.js&quot;,      &quot;require&quot;: &quot;./dist/my-lib.umd.cjs&quot;    &#125;  &#125;&#125;\n\n十、如何实现国际化？Vue 应用程序本身实现国际化比较简单，使用 vue-i18n 很容易达到目的。首先是创建并安装 i18n 实例：\nconst i18n = createI18n(&#123;  locale: &#x27;ja&#x27;,  fallbackLocale: &#x27;en&#x27;,  messages: &#123;    en: &#123;      message: &#123;        hello: &#x27;hello world&#x27;      &#125;    &#125;,    ja: &#123;      message: &#123;        hello: &#x27;こんにちは、世界&#x27;      &#125;    &#125;  &#125;&#125;)const app = createApp(Vue)app.use(i18n)app.mount(&#x27;#app&#x27;)\n然后在模板中直接使用即可：\n&lt;template&gt;  &lt;h1&gt;&#123;&#123; $t(&#x27;message.hello&#x27;) &#125;&#125;&lt;/h1&gt;&lt;/template&gt;\n那在依赖包中如何实现国际化呢？首先想到的是采用 Element Plus 的方案，完全自己实现，但既然我们的主体应用程序（就是使用了上述几个子包的主程序，也就是某个产品或项目的具体应用程序）不可避免的需要使用 vue-i18n，那能否借助它来实现子包的国际化呢？答案是肯定的。TODO: 未完待续。\n","categories":["Vue"]},{"title":"Obsidian插件开发","url":"/2024/10/10/Obsidian%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/","content":"背景之所以要开发 Obsidian 插件，是因为之前整理了通过Gitee的OpenAPI实现图床，想着将 Obsidian 的图片也上传到图床，然后生成链接，这样就可以在 Obsidian 中直接使用图片链接了。\n但是后来想到，Obsidian 还是可以插入文件的，如果将文件也上传到图床固然可行，但是文件的预览就不太方便了。因为 Obsidian 中仅是插入了文件链接，点击之后实际是通过浏览器打开的，像 .docx 等文件浏览器是不支持预览的，所以就直接下载下来了，这种体验并不友好。\n最终想了想，Obsidian 的笔记其实还是同步到 iCloud 中的（自己配置的），所以图片、文件也都保持这种方式吧。\n但是插件已经开发出来了，这里就记录一下开发过程。\n开发文档开发文档可以参考Obsidian 插件开发文档，步骤还是很详细的，示例工程都有了。\n上传文件到 Gitee我的这个插件想要实现的功能是，将粘贴或拖拽到 Obsidian 中的图片、文件自动上传到 Gitee，并生成链接，然后直接插入到笔记中。\n插件配置首先，需要配置 Gitee 的相关信息，包括用户名、仓库地址、分支名、token 等。\nconst DEFAULT_SETTINGS: MyPluginSettings = &#123;  repo: &#x27;&#x27;,  branch: &#x27;master&#x27;,  path: &#x27;/&#x27;,  token: &#x27;&#x27;,&#125;;\n\n事件监听然后，需要监听 Obsidian 中的粘贴和拖拽事件，当有图片或文件被粘贴或拖拽到 Obsidian 中时，触发上传操作。\nasync onload() &#123;  await this.loadSettings();  this.registerEvent(    this.app.workspace.on(&#x27;editor-paste&#x27;, (event, editor, content) =&gt; &#123;      this.uploadFiles(event.clipboardData?.files, event, editor);    &#125;)  );  this.registerEvent(    this.app.workspace.on(&#x27;editor-drop&#x27;, (event, editor, content) =&gt; &#123;      this.uploadFiles(event.dataTransfer?.files, event, editor);    &#125;)  );&#125;uploadFiles(files: FileList | undefined, event: ClipboardEvent | DragEvent, editor: Editor) &#123;  if (!files?.length) return;  event.preventDefault();  event.stopPropagation();  if (this.settings.subPathable) &#123;    new SampleModal(this.app, files, editor, this.settings).open();  &#125;  else &#123;    uploadToGitee(files, this.settings).then((res) =&gt; &#123;      editor.replaceSelection(res.filter(x =&gt; x).join(&#x27;\\n&#x27;));    &#125;)  &#125;&#125;\n\n上传图片上传图片的功能比较简单，直接使用 Gitee 提供的 API 即可。\nfunction uploadToGitee(fileList: FileList, settings: MyPluginSettings, filePath: string = &#x27;&#x27;) &#123;  const tooLargeFiles = Array.from(fileList).filter(file =&gt; file.size &gt; 1024 * 1024 * 10);  if (tooLargeFiles.length) &#123;    new Notice(`文件大小不能超过10MB，$&#123;tooLargeFiles.map(file =&gt; file.name).join(&#x27;、&#x27;)&#125;将会被丢弃`, 5000);  &#125;  return Promise.all(Array.from(fileList).filter(file =&gt; file.size &lt;= 1024 * 1024 * 10).map(file =&gt; &#123;    return new Promise((resolve, reject) =&gt; &#123;      const reader = new FileReader();      reader.onload = async () =&gt; &#123;        axios.post(`https://gitee.com/api/v5/repos/$&#123;settings.repo&#125;/contents/$&#123;settings.path&#125;/$&#123;filePath&#125;/$&#123;file.name&#125;`, &#123;          access_token: settings.token,          content: (reader.result as string).replace(`data:$&#123;file.type&#125;;base64,`, &#x27;&#x27;),          message: &#x27;upload image&#x27;        &#125;)          .then(res =&gt; &#123;            resolve(file.type.includes(&#x27;image&#x27;) ? `![$&#123;file.name&#125;]($&#123;res.data.content.download_url&#125;)` : res.data.content.download_url)          &#125;)          .catch(err =&gt; &#123;            new Notice(`上传文件$&#123;file.name&#125;失败，失败原因：$&#123;err.response.data.message&#125;`, 5000);            resolve(&#x27;&#x27;)          &#125;)      &#125;;      reader.onerror = err =&gt; &#123;        new Notice(`文件读取$&#123;file.name&#125;失败`, 5000);        resolve(&#x27;&#x27;)      &#125;;      reader.readAsDataURL(file);    &#125;)  &#125;))&#125;\n\n代码地址https://github.com/DoAutumn/img-plugin-obsidian\n","categories":["工具"],"tags":["Obsidian"]},{"title":"http-server开启https服务","url":"/2022/08/17/http-server%E5%BC%80%E5%90%AFhttps%E6%9C%8D%E5%8A%A1/","content":"问题直接使用 http-server 命令开启的是 http 服务，在 npmjs 的官网地址中只是看到了 http-server -S 是开启 https 服务的方法，但是我这边直接使用该命令会报如下所示的错误，具体原因是没有证书密钥对文件。\n解决方法\n1、下载安装openssl\n2、使用以下命令生成一个证书密钥对 key.pem 和 cert.pem，设置有效期约10年（准确地说是3650天）openssl req -newkey rsa:2048 -new -nodes -x509 -days 3650 -keyout key.pem -out cert.pem\n3、然后就可以起服务了http-server -S\n\n\n下面这个记不清是在什么场景下使用的了在html的头部加入meta使得所有的资源请求由http请求转成https请求&lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;upgrade-insecure-requests&quot;&gt;\n","categories":["工具"]},{"title":".gitignore文件不起作用的原因及解决办法","url":"/2025/01/13/gitignore%E6%96%87%E4%BB%B6%E4%B8%8D%E8%B5%B7%E4%BD%9C%E7%94%A8%E7%9A%84%E5%8E%9F%E5%9B%A0%E5%8F%8A%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/","content":"项目开发中使用Git作为版本管理工具时，有时并非在项目一开始就添加了.gitignore文件来管理Git忽略规则，或是在项目开发过程中添加或移除了忽略规则，这时由于Git在本地维护着一份遵从创建本地项目时的gitignore规则的Git缓存，因此会造成.gitignore文件不起作用的现象。\n解决这个问题的方式就是清除掉本地项目的Git缓存，通过重新创建Git索引的方式来生成遵从新.gitignore文件中规则的本地Git版本，再将该Git版本提交到主干。\n具体命令：\ngit rm -r --cached .git add .git commit -m &quot;update .gitignore&quot;","categories":["Git"],"tags":[".gitignore"]},{"title":"Linux无外网全局安装node依赖包","url":"/2023/03/27/linux%E6%97%A0%E5%A4%96%E7%BD%91%E5%85%A8%E5%B1%80%E5%AE%89%E8%A3%85node%E4%BE%9D%E8%B5%96%E5%8C%85/","content":"\n首先在本地全局安装需要的包npm i -g http-server，（注意：本地必须是全局安装），进入全局安装路径，比如我的电脑安装路径在这里：/usr/local/lib/node_modules/，\n在linux上找到node安装路径，进入其lib/node_modules/目录下，将上述包上传至该目录下\n建立软连接以便全局使用命令：ln -s /usr/local/src/nodejs/lib/node_modules/http-server/bin/http-server /usr/local/bin/http-server\n\n","categories":["Linux"]},{"title":"markdown文件转word文件","url":"/2023/01/11/markdown%E6%96%87%E4%BB%B6%E8%BD%ACword%E6%96%87%E4%BB%B6/","content":"步骤\n1、安装nodejs\n2、安装marked，npm i marked\n3、转换成doc格式前，需要把md文件转换为html标签格式，才能保留doc文件中的样式，新建立head.html模板文件，内容如下：&lt;html&gt;  &lt;head&gt;  &lt;meta charset=&quot;utf-8&quot;&gt;  &lt;title&gt;Markdoc Preview&lt;/title&gt;  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;  &lt;style type=&quot;text/css&quot;&gt;html &#123;font-family: sans-serif; -ms-text-size-adjust: 100%; -webkit-text-size-adjust: 100%; &#125;body &#123;margin: 0;&#125;article,aside,details,figcaption,figure,footer,header,hgroup,main,nav,section,summary &#123;display: block;&#125;audio,canvas,progress,video &#123;display: inline-block; vertical-align: baseline; &#125;audio:not([controls]) &#123;display: none;height: 0;&#125;[hidden],template &#123;display: none;&#125;a &#123;background: transparent;&#125;a:active,a:hover &#123;outline: 0;&#125;abbr[title] &#123;border-bottom: 1px dotted;&#125;b,strong &#123;font-weight: bold;&#125;dfn &#123;font-style: italic;&#125;h1 &#123;font-size: 2em;margin: 0.67em 0;&#125;mark &#123;background: #ff0;color: #000;&#125;small &#123;font-size: 80%;&#125;sub,sup &#123;font-size: 75%;line-height: 0;position: relative;vertical-align: baseline;&#125;sup &#123;top: -0.5em;&#125;sub &#123;bottom: -0.25em;&#125;img &#123;border: 0;&#125;svg:not(:root) &#123;overflow: hidden;&#125;figure &#123;margin: 1em 40px;&#125;hr &#123;-moz-box-sizing: content-box;box-sizing: content-box;height: 0;&#125;pre &#123;overflow: auto;&#125;code,kbd,pre,samp &#123;font-family: monospace, monospace;font-size: 1em;&#125;button,input,optgroup,select,textarea &#123;color: inherit; font: inherit; margin: 0; &#125;button &#123;overflow: visible;&#125;button,select &#123;text-transform: none;&#125;button,html input[type=&quot;button&quot;], input[type=&quot;reset&quot;],input[type=&quot;submit&quot;] &#123;-webkit-appearance: button; cursor: pointer; &#125;button[disabled],html input[disabled] &#123;cursor: default;&#125;button::-moz-focus-inner,input::-moz-focus-inner &#123;border: 0;padding: 0;&#125;input &#123;line-height: normal;&#125;input[type=&quot;checkbox&quot;],input[type=&quot;radio&quot;] &#123;box-sizing: border-box; padding: 0; &#125;input[type=&quot;number&quot;]::-webkit-inner-spin-button,input[type=&quot;number&quot;]::-webkit-outer-spin-button &#123;height: auto;&#125;input[type=&quot;search&quot;] &#123;-webkit-appearance: textfield; -moz-box-sizing: content-box;-webkit-box-sizing: content-box; box-sizing: content-box;&#125;input[type=&quot;search&quot;]::-webkit-search-cancel-button,input[type=&quot;search&quot;]::-webkit-search-decoration &#123;-webkit-appearance: none;&#125;fieldset &#123;border: 1px solid #c0c0c0;margin: 0 2px;padding: 0.35em 0.625em 0.75em;&#125;legend &#123;border: 0; padding: 0; &#125;textarea &#123;overflow: auto;&#125;optgroup &#123;font-weight: bold;&#125;table &#123;border-collapse: collapse;border-spacing: 0;&#125;td,th &#123;padding: 0;&#125;* &#123;-webkit-box-sizing: border-box;-moz-box-sizing: border-box;box-sizing: border-box;&#125;*:before,*:after &#123;-webkit-box-sizing: border-box;-moz-box-sizing: border-box;box-sizing: border-box;&#125;html &#123;font-size: 62.5%;-webkit-tap-highlight-color: rgba(0, 0, 0, 0);&#125;body &#123;font-family: &#x27;Helvetica Neue&#x27;, Helvetica, Arial, &#x27;Microsoft Yahei&#x27;, sans-serif;font-size: 14px;line-height: 1.42857143;color: #333333;background-color: #ffffff;&#125;input,button,select,textarea &#123;font-family: inherit;font-size: inherit;line-height: inherit;&#125;a &#123;color: #428bca;text-decoration: none;&#125;a:hover,a:focus &#123;color: #2a6496;text-decoration: underline;&#125;a:focus &#123;outline: thin dotted;outline: 5px auto -webkit-focus-ring-color;outline-offset: -2px;&#125;figure &#123;margin: 0;&#125;img &#123;vertical-align: middle;&#125;.hljs &#123;display: block;overflow-x: auto;padding: 0.5em;background: #f0f0f0;-webkit-text-size-adjust: none;&#125;.hljs,.hljs-subst,.hljs-tag .hljs-title,.nginx .hljs-title &#123;color: black;&#125;.hljs-string,.hljs-title,.hljs-constant,.hljs-parent,.hljs-tag .hljs-value,.hljs-rules .hljs-value,.hljs-preprocessor,.hljs-pragma,.haml .hljs-symbol,.ruby .hljs-symbol,.ruby .hljs-symbol .hljs-string,.hljs-template_tag,.django .hljs-variable,.smalltalk .hljs-class,.hljs-addition,.hljs-flow,.hljs-stream,.bash .hljs-variable,.apache .hljs-tag,.apache .hljs-cbracket,.tex .hljs-command,.tex .hljs-special,.erlang_repl .hljs-function_or_atom,.asciidoc .hljs-header,.markdown .hljs-header,.coffeescript .hljs-attribute &#123;color: #800;&#125;.smartquote,.hljs-comment,.hljs-annotation,.diff .hljs-header,.hljs-chunk,.asciidoc .hljs-blockquote,.markdown .hljs-blockquote &#123;color: #888;&#125;.hljs-number,.hljs-date,.hljs-regexp,.hljs-literal,.hljs-hexcolor,.smalltalk .hljs-symbol,.smalltalk .hljs-char,.go .hljs-constant,.hljs-change,.lasso .hljs-variable,.makefile .hljs-variable,.asciidoc .hljs-bullet,.markdown .hljs-bullet,.asciidoc .hljs-link_url,.markdown .hljs-link_url &#123;color: #080;&#125;.hljs-label,.hljs-javadoc,.ruby .hljs-string,.hljs-decorator,.hljs-filter .hljs-argument,.hljs-localvars,.hljs-array,.hljs-attr_selector,.hljs-important,.hljs-pseudo,.hljs-pi,.haml .hljs-bullet,.hljs-doctype,.hljs-deletion,.hljs-envvar,.hljs-shebang,.apache .hljs-sqbracket,.nginx .hljs-built_in,.tex .hljs-formula,.erlang_repl .hljs-reserved,.hljs-prompt,.asciidoc .hljs-link_label,.markdown .hljs-link_label,.vhdl .hljs-attribute,.clojure .hljs-attribute,.asciidoc .hljs-attribute,.lasso .hljs-attribute,.coffeescript .hljs-property,.hljs-phony &#123;color: #88f;&#125;.hljs-keyword,.hljs-id,.hljs-title,.hljs-built_in,.css .hljs-tag,.hljs-javadoctag,.hljs-phpdoc,.hljs-dartdoc,.hljs-yardoctag,.smalltalk .hljs-class,.hljs-winutils,.bash .hljs-variable,.apache .hljs-tag,.hljs-type,.hljs-typename,.tex .hljs-command,.asciidoc .hljs-strong,.markdown .hljs-strong,.hljs-request,.hljs-status &#123;font-weight: bold;&#125;.asciidoc .hljs-emphasis,.markdown .hljs-emphasis &#123;font-style: italic;&#125;.nginx .hljs-built_in &#123;font-weight: normal;&#125;.coffeescript .javascript,.javascript .xml,.lasso .markup,.tex .hljs-formula,.xml .javascript,.xml .vbscript,.xml .css,.xml .hljs-cdata &#123;opacity: 0.5;&#125;#container &#123;padding: 15px;margin-left:20px;&#125;pre &#123;border: 1px solid #ccc;border-radius: 4px;display: block;&#125;pre code &#123;white-space: pre-wrap;&#125;.hljs,code &#123;font-family: Monaco, Menlo, Consolas, &#x27;Courier New&#x27;, monospace;&#125;pre&#123;background-color: #dddddd;padding:8px 0px 8px 30px;word-wrap: break-word;&#125;table tbody tr:nth-child(2n) &#123;background: rgba(158,188,226,0.12); &#125;:not(pre) &gt; code &#123;padding: 2px 4px;font-size: 90%;color: #c7254e;background-color: #f9f2f4;white-space: nowrap;border-radius: 4px;&#125;th, td &#123;border: 1px solid #ccc;padding: 6px 12px;&#125;blockquote &#123;border-left-width: 10px;background-color: rgba(102,128,153,0.05);border-top-right-radius: 5px;border-bottom-right-radius: 5px;padding: 1px 20px&#125;blockquote.pull-right small:before,blockquote.pull-right .small:before &#123;content: &#x27;&#x27;&#125;blockquote.pull-right small:after,blockquote.pull-right .small:after &#123;content: &#x27;\\00A0 \\2014&#x27;&#125;blockquote:before,blockquote:after &#123;content: &quot;&quot;&#125;blockquote &#123;margin: 0 0 1.1em&#125;blockquote p &#123;margin-bottom: 1.1em;font-size: 1em;line-height: 1.45&#125;blockquote ul:last-child,blockquote ol:last-child &#123;margin-bottom: 0&#125;blockquote &#123;margin: 0 0 21px;border-left: 10px solid #dddddd;&#125;  &lt;/style&gt;  &lt;/head&gt;  &lt;body marginwidth=&quot;0&quot; marginheight=&quot;0&quot;&gt;    &lt;div id=&quot;container&quot;&gt;      replace_area    &lt;/div&gt;  &lt;/body&gt;&lt;/html&gt;\n4、新建js脚本文件convert.js内容如下：var fs = require(&#x27;fs&#x27;);var &#123; marked &#125; = require(&#x27;marked&#x27;);// 读取第3步创建的模板html文件var headFile = fs.readFileSync(&#x27;head.html&#x27;);// 读取将要被转换的md文件var mdFile = fs.readFileSync(&#x27;mark.md&#x27;);// console.log(&#x27;----正在转换...&#x27;);// 调用marked将md文件转换成htmlvar mdToHtmlStr = marked(mdFile.toString());// 将md转换成html字符串替换到html模板文件中replace_area的位置var content = headFile.toString().replace(&#x27;replace_area&#x27;, mdToHtmlStr);// console.log(&quot;准备写入文件&quot;);fs.writeFile(&#x27;output.doc&#x27;, content, function(err) &#123;  if (err) &#123;    return console.error(err);  &#125;  console.log(&quot;数据写入成功！&quot;);&#125;);// console.log(content);\n5、运行脚本node convert.js即可\n\n","categories":["其他"]},{"title":"wangEditor学习与使用","url":"/2023/09/01/wangEditor%E5%AD%A6%E4%B9%A0%E4%B8%8E%E4%BD%BF%E7%94%A8/","content":"一、背景继之前的CKEditor5学习开发之路之后，这又是一篇对富文本编辑器的学习与使用的整理回顾笔记。之所以会再一次研究富文本编辑器，并且目标对象变了，主要是因为CKEditor5的License为GNU General Public License，要求使用者也必须开源，因此只能重新调研，具体调研结果可查看富文本编辑器调研。\n二、技术选型从调研结果来看，除掉CKEditor5，还剩下TinyMCE、wangEditor、Froala Editor是可选的。\n\nTinyMCE\n\n先来说TinyMCE，它的内容区是嵌套了一个iframe，扩展插件的话是新建html、js，在这独立的html、js中写插件的逻辑，而这插件被集成到编辑器并使用的时候，又嵌套了一层iframe。如果要实现插入图表的功能，图表的插入使用肯定不止一个，这种方案似乎不太合适。\n另外它的引用方式也挺奇怪的，默认地，代码会去他们的服务器请求tinymce.min.js，如果是内网环境，则需要单独配置，具体参考这里的步骤8。\n基于这两点原因，最终放弃了它。这里是测试代码。\n\n\nFroala Editor看起来是个不错的选择，但查看代码时，发现前端工程依赖的&quot;froala-editor&quot;: &quot;^4.1.1&quot;并没有公开代码仓，公开出来的是V3版本，其他的公开仓都是适配各种框架的，这。。。开源了个啥\n\nwangEditor很明显也不是理想选择，正如调研结果中提到的，bug较多，但没办法，暂时没找到其他开源可商用的富文本编辑器。\n\n\n三、wangEditor的使用与扩展不过wangEditor的优势也是比较明显的，帮助文档很详细，示例较多，源码结构也很清晰，弄清楚了它的代码逻辑，修复遇到的bug还是比较简单的。这里就不再重复罗列自定义扩展新功能的步骤了，按照其官网教程一步步来即可。附上包含插入图表、占位符的示例代码。只记录下对其bug修复、功能调整的技术细节。\n1、修复在Angular工程中编译报错的bug// packages/core/src/editor/interface.ts// import ee from &#x27;event-emitter&#x27;import * as ee from &#x27;event-emitter&#x27;  // @types/event-emitter中是这么写的：export = ee; 所以需要import * as ee from &#x27;event-emitter&#x27;\n2、修复不设置编辑器高度时，控制台有警告提示、hoverbar、modal位置不对的bug扩展IEditorConfig，使之支持设置minHeight，然后在创建根节点时，设置最小高度\n// packages/core/src/config/interface.ts/** * editor config */export interface IEditorConfig &#123;  ...  minHeight?: string&#125;// packages/core/src/text-area/update-view.ts/** * 生成编辑区域的 elem * @param elemId elemId * @param readOnly readOnly */function genRootElem(elemId: string, readOnly = false, minHeight = &#x27;&#x27;): Dom7Array &#123;  const style = minHeight ? `style=&quot;min-height: $&#123;minHeight&#125;;&quot;` : &#x27;&#x27;  const $elem = $(`&lt;div        id=&quot;$&#123;elemId&#125;&quot;        data-slate-editor        data-slate-node=&quot;value&quot;        suppressContentEditableWarning        role=&quot;textarea&quot;        spellCheck=&quot;true&quot;        autoCorrect=&quot;true&quot;        autoCapitalize=&quot;true&quot;        $&#123;style&#125;    &gt;&lt;/div&gt;`)  // role=&quot;textarea&quot; - 增强语义，div 语义太弱  return $elem&#125;\n3、修复插入分隔线或自定义元素时，总是会在前面空出一行的bug参考插入表格的代码，如果当前是空 p ，则删除该 p\n// packages/table-module/src/module/menu/InsertTable.ts// 如果当前是空 p ，则删除该 pif (DomEditor.isSelectedEmptyParagraph(editor)) &#123;  Transforms.removeNodes(editor, &#123; mode: &#x27;highest&#x27; &#125;)&#125;\n4、修复给到编辑器的html中出现了字号列表中没有的字号时，字号不生效的bug移除在字号列表中查找当前字号的逻辑（字体也是一样的逻辑）\n// packages/basic-modules/src/modules/font-size-family/parse-style-html.ts// const includesSize =//   fontSizeList.find(item =&gt; item.value &amp;&amp; item.value === fontSize) ||//   fontSizeList.includes(fontSize)// 在 fontSizeList 中找不到，也能够设置 fontSizeconst includesSize = trueif (fontSize &amp;&amp; includesSize) &#123;  textNode.fontSize = fontSize&#125;\n5、调整表格创建成功之后宽度默认100%获取表格节点时，将width: &#39;auto&#39;改为width: &#39;100%&#39;即可\n// packages/table-module/src/module/menu/InsertTable.tsfunction genTableNode(rowNum: number, colNum: number): TableElement &#123;  ...  return &#123;    type: &#x27;table&#x27;,    width: &#x27;100%&#x27;,    children: rows,  &#125;&#125;\n6、扩展工具栏按钮BaseButton，使之支持调用menu的onButtonClick方法有时候我们需要在点击工具栏按钮的时候，获取按钮的位置，以便靠近该按钮显示一个自定义浮窗，此时我们需要知道按钮相对编辑器的位置，以确定浮窗的位置。为此，我们扩展BaseButton，使之支持调用menu的onButtonClick方法（当然，前提是menu实现了onButtonClick方法），然后将event传递出来。\n// BaseButton本身已经有onButtonClick方法了，只是menu没有，所以对menu的接口IBaseMenu进行扩展// packages/core/src/menus/interface.tsinterface IBaseMenu &#123;  ...  onButtonClick?: (editor: IDomEditor, e: Event) =&gt; void // 和 exec 类似，但主要是为了得到原始 event&#125;// packages/core/src/menus/bar-item/BaseButton.ts// // 交给子类去扩展// abstract onButtonClick(): void/** * 执行 menu.onButtonClick */protected onButtonClick(e: Event) &#123;  const editor = getEditorInstance(this)  const menu = this.menu  menu.onButtonClick &amp;&amp; menu.onButtonClick(editor, e)&#125;// 注意：BaseButton的所有子类，均需在onButtonClick中调用父类的该方法onButtonClick(e: Event) &#123;  super.onButtonClick(e)  ...&#125;\n7、扩展工具栏下拉选择Select，使之支持始终显示图标，而不是显示选中的文字比如行高，有些富文本编辑器始终显示图标（当然也不能说这样是最好，只是扩展以支持该功能）\n// packages/core/src/menus/interface.tsexport interface ISelectMenu extends IBaseMenu &#123;  readonly alwaysShowIcon?: boolean // 永远显示图标  ...&#125;// packages/core/src/menus/bar-item/Select.tsprivate setSelectedValue() &#123;  const editor = getEditorInstance(this)  const menu = this.menu  const &#123; alwaysShowIcon, iconSvg &#125; = menu  const value = menu.getValue(editor)  const options = menu.getOptions(editor)  const optText = getOptionText(options, value.toString())  const $button = this.$button  const $downArrow = gen$downArrow() // 向下的箭头图标  $button.empty()  // 主要是这里的代码  if (alwaysShowIcon &amp;&amp; iconSvg) &#123;    const $svg = $(iconSvg)    clearSvgStyle($svg)    $button.append($svg)  &#125; else &#123;    $button.text(optText)  &#125;  $button.append($downArrow)&#125;\n四、wangEditor私有化上面我们对其源码修改了这么多，最好是贡献给wangEditor，但存在几点障碍：\n\n作者已经在 2023-08-30 发布了 wangEditor 暂停维护的通知，具体看这里\n我们的修改不一定能够被他们接受（或许有些问题他们不认为是bug，或许有些扩展他们认为不通用）\n加入其团队略微麻烦，具体要求在这里\n\n所以我们需要重新定义包名、指定代码仓、指定npm私服。源码中是使用lerna管理多个包的，因此packages目录下的每个包都需要改，主要修改package.json中的如下属性值：\n&#123;  &quot;name&quot;: &quot;xxx&quot;,  &quot;publishConfig&quot;: &#123;    &quot;registry&quot;: &quot;xxx&quot;  &#125;,  &quot;repository&quot;: &#123;    &quot;url&quot;: &quot;xxx&quot;  &#125;&#125;\n需要注意一点，如果我们新的代码仓不是在GitHub上，那么在lerna将git tag push到远程时，就不会触发原有的配置git action，此时需要我们手动发包。所以，调整之后的完整的开发、发包流程如下：\n- 下载代码到本地，进入 `wangEditor` 目录- 安装所有依赖 `yarn bootstrap`- 开发功能，完成之后将代码合并到 `master` 分支- 打包所有模块 `yarn dev` 或者 `yarn build`- 生成版本并利用 lerna 自动 push `yarn release:version`- 手动发包 `yarn release:publish`","categories":["富文本编辑器"],"tags":["富文本编辑器","wangEditor","TinyMCE"]},{"title":"一文彻底看懂package.json中的各种dependencies","url":"/2022/08/31/%E4%B8%80%E6%96%87%E5%BD%BB%E5%BA%95%E7%9C%8B%E6%87%82package-json%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8Ddependencies/","content":"关于package.json中的各种dependencies的详细解释，可以直接参考这篇文章。\n这里只做一个最终结论的摘录。\n\n\n\n依赖类型\n定义在项目中\n定义在依赖中\n一句话总结\n举例\n\n\n\ndependencies\n会被安装\n会被安装\n定义包运行所需要的依赖包\n某前端项目使用 react 进行开发，需要将 react 添加到 dependencies 中\n\n\ndevDependencies\n会被安装\n不会被安装\n定义包在开发时所需要的依赖包\nantd 使用了 @testing-library&#x2F;react 进行测试，需要将 @testing-library&#x2F;react 添加到 devDependencies 中\n\n\npeerDependencies\n不会被安装\n不会被安装，但是如果指向的依赖没有被安装或不符合时会有警告（peerDependenciesMeta 会影响该行为）\n定义该包运行所需要的依赖环境，一般和 devDependencies 一起使用\nantd 是一个 react 组件库，为了不和使用它的项目中的 react 版本定义造成冲突，需要将支持的 react 版本添加到 peerDependencies 中\n\n\noptionalDependencies\n会被安装，但是安装报错不会影响\n会被安装，但是安装报错不会影响\noptionalDependencies 用于定义对包运行不会造成影响的依赖包\n一个包在使用 A 包进行了某些操作，但是如果 A 包不在的话，可以使用别的 API 达到同样的效果，可以将 A 包添加到 optionalDependencies 中\n\n\n\n另外记录下版本号的格式规定：固定版本：如4.0.3～：如～4.0.3，表示安装 4.0.x 的最新版本，也就是说安装时不会改变主版本号和次版本号^：如^17.0.2，表示安装 17.x.x 的最新版本，也就是说安装时不会改变主版本号latest：安装最新版本\n","categories":["其他"]},{"title":"VS Code的一些偏好设置","url":"/2023/02/22/vscode%E7%9A%84%E4%B8%80%E4%BA%9B%E5%81%8F%E5%A5%BD%E8%AE%BE%E7%BD%AE/","content":"VS Code作为前端开发的必备神器，其作用自然不必多说。这里记录下个人的使用习惯，免得以后再查。\n1.颜色主题使用这个：Monokai\n2.通过code命令快速启动如果想在某目录下直接通过code ./命令打开vscode，需做如下配置：\n打开vscode，command + shift + p，然后输入shell，选择Install &#39;code&#39; command in PATH\n3.保存全部文件默认command + s只保存当前文件，如果想保存全部文件，需做如下配置：\nPreferences ——&gt; Keyboard Shortcuts ——&gt; 找到 Save All Files，将其命令设置为command + s即可\n4.设置缩进为2个空格Preferences ——&gt; Settings\n——&gt; 找到 Tab Size，将值改为2\n——&gt; 找到 Detect Indentation，将前边的复选框的勾选取消（配置全局文件为2个空格，不勾选则以前文件不变）\n5.关闭顶部固定区域vscode从某个版本开始，在滚动左侧目录树、编辑区代码时，会在顶部保留层级结构，其实不好用，需要将其关闭\nPreferences ——&gt; Settings ——&gt; 搜索sticky ——&gt; 将其所有复选框均取消即可\n6.安装Extensions\nGitLens\nVue - Official\nVue VSCode Snippets(Vue代码片段，方便快速生成代码，如vbase可直接生成&lt;template&gt;、&lt;script&gt;、&lt;style&gt;等)\nCodeGeeX(AI代码助手)\n\n","categories":["工具"],"tags":["vscode"]},{"title":"一种基于Angular的半插件式的功能扩展方案","url":"/2023/03/03/%E4%B8%80%E7%A7%8D%E5%9F%BA%E4%BA%8EAngular%E7%9A%84%E5%8D%8A%E6%8F%92%E4%BB%B6%E5%BC%8F%E7%9A%84%E5%8A%9F%E8%83%BD%E6%89%A9%E5%B1%95%E6%96%B9%E6%A1%88/","content":"前言为什么说是半插件式的呢？因为它并不像比如Chrome浏览器安装扩展程序那样，可以在线安装。但是它又基本上能够达到插件的效果，也即如果附带了某个功能模块，则该功能可以正常使用，如果不带对整个产品也没有任何影响，所以就叫它半插件式吧。\n背景我们产线在产品化的过程中，对前端基础框架提出了这样一个要求，需要提供一个基础版本、一个扩展版本，扩展版本包含一些额外的功能，比如不想开放给其他产线的高级功能。其实像这种功能模块的授权控制，一般都会采用License（软件离线许可License实现原理、软件License设计思路与实现方案）的设计方案，比如CleanMyMac，免费版只能使用有限的功能，购买之后才能解锁全部功能。\n但是我们想要实现的目标和License授权控制还是有些差别的，具体表现为：\n\n我们的高级功能始终不会对外提供，也就意味着我们不想在打包之后的代码里能够看到关于高级功能的任何代码\n我们需要提供两个开发包，一个对内，一个对外，不能让其他产线知道我们有内部开发包\n\n方案预选按照以往偷懒式的开发习惯，一般会有两种解决方案：\n方案一：通过配置属性控制缺点：\n\n需要人为干预，每次发版都需要人为的修改属性值，基础版改为这个值，扩展版改为那个值。。。\n功能的隐蔽性不够好，一旦别人知道了这个配置属性，意味着对应的功能直接就暴露出去了，而且高级功能的代码肯定也都打进包里了\n代码的可维护性不够好，引入的控制变量可能会越来越多，有控制这个功能的，有控制那个功能的。。。\n不具备可扩展性，如果想再增加一个功能，只能修改现有代码\n\n方案二：开启两个代码分支缺点：\n\n通用功能的代码同步将会比较麻烦\n\n显然这两种方案都不能够令人满意，好在前期有微前端开发经验的积累，很快想到了第三种方案：在启动AppModule时将所需功能模块注入到应用程序中，动态设置路由、创建组件\n实现思路关于Angular的依赖注入，可以参考这里：Angular依赖注入介绍、Angular依赖注入教程\n1.不同的模块，如何保证能够统一的解析加载运行？为了保证应用程序在动态加载扩展功能模块时能够有统一的处理逻辑，抽象出一个扩展类Advanced，包含该模块的路由路径path、模块名称label、默认显示到界面的组件component、其他信息，所有模块都继承Advanced\nexport abstract class Advanced &#123;  static component: any;  static path: string;  static label: string;&#125;\n@NgModule(&#123;  declarations: [    Demo3Component,    IconComponent  ],  imports: [    CommonModule,    RouterModule.forChild([&#123; path: &#x27;&#x27;, component: Demo3Component &#125;])  ]&#125;)export class Demo3Module extends Advanced &#123; &#125;Demo3Module.component = IconComponent;Demo3Module.path = &#x27;demo3&#x27;;Demo3Module.label = &#x27;消息中心&#x27;;\n\n2.有了Module，如何注入给应用程序？注入之后通过什么获取到注入的Module？自定义一个依赖注入令牌AdvancedToken，用于注入、获取Module\nexport const AdvancedToken: InjectionToken&lt;Advanced&gt; = new InjectionToken(&#x27;AdvancedToken&#x27;);\n\n3.代码如何实现？注入代码：\nconst list = [  &#123; provide: AdvancedToken, useValue: Demo3Module &#125;  // 当然这里可以注入多个];if (environment.version === &#x27;basic&#x27;) list.length = 0;platformBrowserDynamic(list)  .bootstrapModule(AppModule)  .catch(err =&gt; console.error(err));\n获取代码：\n// 在基础版里，如果获取不到注入的module，则直接return，也就意味着基础版里没有扩展的功能模块try &#123; module = this.injector.get(AdvancedToken) &#125; catch (error) &#123; &#125;;  // 如果上面注入的是多个，则这里获取到的是一个集合if (!module) return;\n\n4.代码如何抽离？通过上述3步，其实Demo3Module的代码还是被打进了基础版的最终代码里，也就是说，虽然if (environment.version === &#39;basic&#39;) list.length = 0;这行代码把集合置空了，但那是执行态的事，打包时并没有识别，因此Demo3Module也就被包含进去了。\n既然这样，那我们可以参考environment.ts的形式新增一个main.basic.ts，在打包时动态替换掉main.ts即可，具体步骤包括：1、新增main.basic.ts\nplatformBrowserDynamic().bootstrapModule(AppModule)  // 不包含任何注入的Module  .catch(err =&gt; console.error(err));\n\n2、tsconfig.app.json中添加main.basic.ts\n&#123;  ...  &quot;files&quot;: [    &quot;src/main.ts&quot;,    &quot;src/main.basic.ts&quot;,    &quot;src/polyfills.ts&quot;  ],  ...&#125;\n\n3、angular.json中配置basic打包参数\n&quot;basic&quot;: &#123;  ...  &quot;fileReplacements&quot;: [    &#123;      &quot;replace&quot;: &quot;src/main.ts&quot;,      &quot;with&quot;: &quot;src/main.basic.ts&quot;    &#125;  ]  ...&#125;\n\n4、package.json中配置basic打包命令\n&quot;scripts&quot;: &#123;  &quot;build&quot;: &quot;ng build&quot;,  &quot;build:basic&quot;: &quot;ng build --configuration=basic&quot;&#125;\n\n最终代码https://github.com/DoAutumn/like-plugin\n","categories":["Angular"],"tags":["Angular插件","License"]},{"title":"个人博客新评论邮件提醒功能","url":"/2024/12/31/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%96%B0%E8%AF%84%E8%AE%BA%E9%82%AE%E4%BB%B6%E6%8F%90%E9%86%92%E5%8A%9F%E8%83%BD/","content":"昨天无意间在打开科学上网的情况下访问了我的博客，发现有一条评论，都已经是11&#x2F;08的了，当初搭建博客的时候，虽然配置了使用 Valine 评论系统，但是没有配置评论提醒功能，而且昨天刚发现，在没有开启科学上网的情况下，也加载不到评论，今天就来解决下这两个问题。\n加载不到评论的问题通过浏览器的 Network 可以看到，在没有科学上网的情况下，有一个 av-min.js 文件加载失败，怀疑是它导致的。\n通过排查，发现这个文件是由 Valine.min.js 文件加载的，而 Valine.min.js 在博客所使用的主题 maupassant 中是能够找到的：\n// maupassant/layout/_partial/comments.pugscript(src=&#x27;//unpkg.com/valine@latest/dist/Valine.min.js&#x27;)\n那我们只需要把这两个文件改成本地的就可以了。\n将两个文件保存到 maupassant/source/js/ 目录下，然后修改 comments.pug 文件\nscript(type=&#x27;text/javascript&#x27;, src=url_for(theme.js) + &#x27;/Valine.min.js&#x27; + &#x27;?v=&#x27; + theme.version)\n同时修改 Valine.min.js 中对于 av-min.js 的引用地址 /js/av-min.js 即可。\n邮件提醒Valine 自带的邮件提醒功能在 v1.4.0 中已经被移除了，具体可查看这里，不过可以通过 Valine Admin 来实现评论提醒功能。\n可以看到上面这个 Valine Admin 是 Fork 自 DesertsP 的 Valine Aadmin 的，两个仓里都有配置步骤，但都有点问题，这里记录下。\n1. 代码库地址Git 部署时，需要使用 DesertsP 的代码库，因为 zhaojun1998 的代码库在部署时会报错。\n2. 环境变量在配置环境变量时，DesertsP 里面列的更全，我自己的是这样的：其中：\n\nSMTP_PASS：网易邮箱的授权码，默认有效期是 180 天。\nADMIN_URL：是在 环境变量 下方 绑定新域名 处设置的，DesertsP 和 zhaojun1998 的截图，跟现在最新的 LeanCloud 的控制台页面已经对不上了。\n\n3. 定时任务\n\n\n2025-01-08 更新：通过定制任务唤醒实例、检查漏发邮件已经不可用\n\n","categories":["其他"],"tags":["Valine","LeanCloud"]},{"title":"产品版本规则","url":"/2022/07/17/%E4%BA%A7%E5%93%81%E7%89%88%E6%9C%AC%E8%A7%84%E5%88%99/","content":"\nalpha：内测版软件的初级版本，表示该软件在此阶段以实现软件功能为主，通常只在软件开发者内部交流，一般而言，该版本软件的Bug较多，需要继续修改，是测试版本。测试人员提交Bug经开发人员修改确认之后，发布到测试网址让测试人员测试，此时可将软件版本标注为alpha版。 \n\nbeta：公测版该版本相对于alpha版已经有了很大的进步，消除了严重错误，但还需要经过多次测试来进一步消除，此版本主要的修改对象是软件的UI。修改的Bug经测试人员测试确认后可发布到外网上，此时可将软件版本标注为beta版。 \n\ndemo：演示版在非正式版软件中，该版本的知名度最大。demo版仅仅集成了正式版中的几个功能，颇有点像unregistered。不同的是，demo版一般不能通过升级或注册的方法变为正式版。 \n\nrc：即将作为正式版发布该版本已经相当成熟了，基本上不存在导致错误的Bug，与即将发行的正式版本相差无几。 \n\nrelease：发行版该版本意味“最终版本”，在前面版本的一系列测试版之后，终归会有一个正式的版本，是最终交付用户使用的一个版本。该版本有时也称标准版。 \n\nexpress：快速版相比于标准版、企业版，在功能上提供的较少或者是增减一些定制性的功能。 \n\nstandard：标准版这是最常见的标准版，不论是什么软件，标准版一定存在。标准版中包含了该软件的基本组件及一些常用功能，可以满足一般用户的需求。其价格相对高一级版本而言还是“平易近人”的。 \n\nenterprise（企业版）企业版是开发类软件中的极品（相当于百科全书中的reference版）。拥有一套这种版本的软件可以毫无障碍地开发任何级别的应用软件。如著名的visual c++的企业版相对于专业版来说增加了几个附加的特性，如sql调试、扩展的存储过程向导、支持as&#x2F;400对ole db的访问等。而这一版本的价格也是普通用户无法接受的。如微软的visual studios 6.0 enterprise 中文版的价格为 23000 元。\n\n\n","categories":["其他"]},{"title":"产品版本递增规范及代码分支管理要求","url":"/2023/01/05/%E4%BA%A7%E5%93%81%E7%89%88%E6%9C%AC%E9%80%92%E5%A2%9E%E8%A7%84%E8%8C%83%E5%8F%8A%E4%BB%A3%E7%A0%81%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E8%A6%81%E6%B1%82/","content":"到目前为止，关于数字货币交易平台的项目总共有3个，分别是前台页面项目、后端接口和后台管理的项目、撮合服务项目。后续可能还会有更多的项目要进行维护。 \n1. 代码版本递增规范现在对这些项目的版本号进行规范管理，每次项目版本号的迭代，都需要管理人员统一商定，并严格按照以下要求来制定版本号。 \n版本格式：v + 主版本号.次版本号.修订号，比如 v1.0.1，注意v小写。版本号中的数字最多不能超过3位。版本号递增规则如下： \n\n主版本号：当做了不兼容的 API 修改，或者重大架构更新时。 \n\n次版本号：当做了向下兼容的功能性新增、更新时。 \n\n修订号：当做了向下兼容的bug修复时。\n\n\n2. 代码分支管理要求鉴于之前的代码合并过程中，发生了部分未完成的代码被合并到开发分支的情况，导致了代码无法进行快速拆分和版本标记，所以以后要求所有开发人员及管理人员必须严格遵照Git Flow来做代码分支的管理。 \n以下关于本团队代码分支管理要求的内容，均参照于这里关于Git Flow的描述：Git三大特色之WorkFlow(工作流) \n2.1 长期分支一个项目中，要保证2个长期存在的分支，分别为master和develop分支。这2个分支均设为保护分支（只有项目中的Master角色才能允许其他分支的代码被合并到此分支上）。master分支主要用于标记版本号（即添加Tag）。develop分支用于日常的开发内容合并。develop是master下的分支。 \n2.2 辅助分支除了2个长期存在的分支外，还要有3类辅助分支，辅助分支在被合并后可以删除。分别为Feature Branch、Release Branch 和 Hotfix Branch。 \n2.2.1 Feature Branchfeature分支用来做一个模块/功能开发或更新，分支命名要求：feature/&#123;功能模块简称标识&#125;，不要和其他类型的分支命名弄混淆就好，举个坏例子，命名为 master 就是一个非常不妥当的举动。 \n该分支上的功能完成后，申请合并到 develop 分支，并选择被合并后删除该分支。 \n如果一个功能模块只有一个开发人员来进行，那么该开发人员可以在该feature分支上直接进行开发。 \n如果一个功能模块由多个开发人员来进行，那么为了避免代码冲突和覆盖，每个开发人员需要在该feature分支上检出各自的分支，命名要求：feature/&#123;功能模块简称标识&#125;/&#123;开发人员姓名全拼&#125;，开发完毕后将各自分支上的代码合并到feature分支上。 \n2.2.2 Release Branchrelease分支用来做版本发布的预发布分支，分支命名要求：release/&#123;预发布的版本号&#125;。例如在软件 v1.0 版本的功能全部开发完成，并且已经被合并到develop分支后，那么从develop分支检出release&#x2F;v1.0分支，将release&#x2F;v1.0分支上的代码部署到测试服务环境中。测试过程中出现的问题，可在该release分支上进行修改提交。涉及多个开发人员的话，需要在该release分支上检出各自的分支进行修改，命名要求：release/v1.0/&#123;开发人员姓名全拼&#125;。 \n测试完毕准备发布的时候，将该release分支上的代码分别合并到 master 和 develop分支，合并到master 分支后要打上对应版本标签 v1.0，同时写明功能模块新增&#x2F;更新的详细描述。记住，待合并到master和develop分支之后，删除该release分支。 \nrelease分支的好处是，在测试的时候，不影响下一个版本功能的并行开发。 \n2.2.3 Hotfix Branchhotfix分支是用来做线上的紧急 bug 修复的分支，命名要求：hotfix/&#123;bug简称标识&#125;。当线上代码出现了问题，从master分支直接检出hotfix分支，然后在该hotfix上修复bug。涉及多个开发人员的话，需要在该hotfix分支上检出各自的分支进行修改，命名要求：hotfix/&#123;bug简称标识&#125;/&#123;开发人员姓名全拼&#125;。 \n待问题修复后，将hotfix分支中的代码合并到 master 和 develop 分支，全部合并完成后删除该hotfix分支。注意，合并到 master 分支的时候，要打上修复后的版本标签，比如从v1.0 -&gt; v1.0.1，同时要写明修复bug的详细描述。 \n2.3 Git Flow示意图上述关于长期分支和辅助分支之间的工作切换流程，可以总结为下面的一张图。\n","categories":["Git"]},{"title":"从零构建可扩展的 Angular 问答渲染器 SDK","url":"/2025/09/02/%E4%BB%8E%E9%9B%B6%E6%9E%84%E5%BB%BA%E5%8F%AF%E6%89%A9%E5%B1%95%E7%9A%84%20Angular%20%E9%97%AE%E7%AD%94%E6%B8%B2%E6%9F%93%E5%99%A8%20SDK/","content":"在开发类似豆包、通义千问的问答产品时，前端经常需要处理大模型返回的多样化内容 —— 表格、图表、参考文档、工具调用等，甚至未来可能出现视频、音频等新类型。如果将所有渲染逻辑耦合在一起，不仅代码臃肿难维护，后续扩展新类型更是举步维艰。\n本文将带你从零设计并实现一个可扩展的 Angular 问答渲染器 SDK，它默认集成表格和图表渲染能力，开发者无需额外配置即可使用；同时支持自定义渲染器注册，完美适配业务的持续迭代需求。\n一、需求与设计目标在动手前，我们先明确 SDK 的核心需求与设计目标，确保架构方向不跑偏：\n核心需求\n\n默认能力：SDK 内置 Table 和 Chart 两种渲染器，开发者导入即可用，无需手动配置；\n灵活扩展：支持开发者自定义渲染器（如参考文档、工具调用），通过简单方式注册到 SDK；\n易用性：提供两种导入方式 —— 无自定义渲染器时直接导入模块，有自定义需求时用 forRoot 配置；\n组件化：基于 Angular 组件封装渲染逻辑，而非原生 DOM 操作，符合 Angular 最佳实践。\n\n设计目标\n\n遵循开闭原则：新增渲染类型无需修改 SDK 核心代码，只需扩展新组件；\n遵循单一职责：每种渲染器只负责对应类型的内容渲染，职责清晰；\n低耦合：渲染逻辑与核心框架解耦，便于独立开发、测试和维护；\n兼容性：默认渲染器与自定义渲染器无缝协作，支持优先级覆盖（可选）。\n\n二、整体架构设计基于需求，我们采用 “接口定义 + 默认实现 + 注册中心 + 动态加载” 的架构模式，整体分为 5 大核心模块：\n\n接口层：定义统一的渲染器接口，保证所有渲染器实现一致性；\n默认渲染器：SDK 内置 Table 和 Chart 渲染器，基于 Angular 组件实现；\n注册中心：通过服务管理所有渲染器（默认 + 自定义），提供注册、查询能力；\n核心渲染容器：根据内容类型（flag）从注册中心匹配渲染器，动态加载并渲染；\n模块封装：对外提供统一的模块入口，支持基础导入和带配置导入两种方式。\n\n三、SDK 核心实现代码地址：https://github.com/doautumn/chat-renderer\n.├── lib│   ├── components│   │   └── renderer-container        // 核心渲染容器│   ├── decorators│   │   └── renderer-decorator.ts     // 装饰器，绑定渲染器与flag│   ├── interfaces│   │   └── on-render.ts              // 渲染器组件接口，所有渲染器组件必须实现此接口，确保都接收 data 输入│   ├── models│   │   └── renderer-model.ts         // 渲染器模型，通义数据结构为 &#123; &quot;flag&quot;: &quot;xxx&quot;, &quot;content&quot;: [...] &#125;│   ├── renderer.module.ts│   ├── renderers                     // 默认渲染器，可覆盖│   │   ├── chart-renderer│   │   └── table-renderer│   ├── services                      // 渲染器注册中心，负责注册、查找渲染器│   │   └── renderer-registry.service.ts│   └── tokens│       └── renderer-config.ts├── public-api.ts└── test.ts\n四、使用方式1. 安装依赖npm install @tui/chat\n\n2. 自定义渲染器import &#123; Component, OnInit &#125; from &#x27;@angular/core&#x27;;import &#123; OnRender, Renderer, RendererModel &#125; from &#x27;@tui/chat&#x27;;@Renderer([&#x27;video&#x27;, &#x27;audio&#x27;])@Component(&#123;  selector: &#x27;media-renderer&#x27;,  template: `    &lt;div class=&quot;media-container&quot;&gt;      &lt;video *ngIf=&quot;data.flag === &#x27;video&#x27;&quot; [src]=&quot;data.content[0].src&quot; controls&gt;&lt;/video&gt;      &lt;audio *ngIf=&quot;data.flag === &#x27;audio&#x27;&quot; [src]=&quot;data.content[0].src&quot; controls&gt;&lt;/audio&gt;      &lt;p&gt;&#123;&#123; data.content[0].title &#125;&#125;&lt;/p&gt;    &lt;/div&gt;  `&#125;)export class MediaRendererComponent implements OnInit, OnRender &#123;  data: RendererModel;  ngOnInit(): void &#123;  &#125;&#125;\n\n3. 引入模块并注册自定义渲染器import &#123; RendererModule &#125; from &#x27;@tui/chat&#x27;;@NgModule(&#123;  // 无自定义渲染器时  imports: [    RendererModule  ],  // 有自定义渲染器时  imports: [    RendererModule.forRoot(&#123;      renderers: [MediaRendererComponent]    &#125;)  ],&#125;)export class AppModule &#123;&#125;\n\n4. 使用组件import &#123; RendererModel &#125; from &#x27;@tui/chat&#x27;;// 示例内容数据contents: RendererModel[] = [  &#123;    flag: &quot;table&quot;,    content: [      &#123;        columns: [          &#123; key: &quot;time&quot;, title: &quot;时间&quot; &#125;,          &#123; key: &quot;name&quot;, title: &quot;告警名称&quot;, color: &quot;#43bff4&quot; &#125;,          &#123; key: &quot;ip&quot;, title: &quot;IP&quot; &#125;,          &#123; key: &quot;severity&quot;, title: &quot;严重级别&quot;, colorMapping: &#123; &quot;高&quot;: &quot;#ff4a4a&quot;, &quot;中&quot;: &quot;#eab045&quot;, &quot;低&quot;: &quot;#43bff4&quot; &#125; &#125;,        ],        data: [          &#123; time: &quot;2025-09-01 10:00:00&quot;, name: &quot;SQL注入&quot;, ip: &quot;10.1.10.1&quot;, severity: &quot;高&quot; &#125;,          &#123; time: &quot;2025-09-01 10:00:01&quot;, name: &quot;SQL注入&quot;, ip: &quot;10.1.10.1&quot;, severity: &quot;中&quot; &#125;        ]      &#125;    ],    description: &#x27;这是内置的表格渲染器&#x27;  &#125;,  &#123;    flag: &#x27;chart&#x27;,    content: [      &#123;        title: &#x27;图表标题&#x27;,        chartName: &#x27;TrxLineChart&#x27;,        dataConfig: &#123;          x: [&#x27;time&#x27;],          y: [&#x27;value&#x27;],          data: [            &#123; time: &#x27;2025-09-01&#x27;, value: 100 &#125;,            &#123; time: &#x27;09-02&#x27;, value: 200 &#125;,            &#123; time: &#x27;09-03&#x27;, value: 150 &#125;,            &#123; time: &#x27;09-04&#x27;, value: 400 &#125;,            &#123; time: &#x27;09-05&#x27;, value: 100 &#125;,            &#123; time: &#x27;09-06&#x27;, value: 250 &#125;,            &#123; time: &#x27;09-07&#x27;, value: 700 &#125;,          ]        &#125;      &#125;    ],    description: &#x27;这是内置的图表渲染器&#x27;  &#125;,  &#123;    flag: &#x27;video&#x27;,    content: [      &#123;        src: &#x27;https://www.w3school.com.cn/i/movie.mp4&#x27;,        title: &#x27;视频标题&#x27;      &#125;    ],    description: &#x27;这是自定义的视频渲染器&#x27;  &#125;];\n\n&lt;t-renderer   *ngFor=&quot;let item of contents&quot;   [data]=&quot;item&quot;&gt;&lt;/t-renderer&gt;","categories":["Angular"],"tags":["Angular","渲染器","注册中心","Provided by 豆包"]},{"title":"pm2:以后台服务的形式启动nodejs脚本","url":"/2023/03/27/%E4%BB%A5%E5%90%8E%E5%8F%B0%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%BD%A2%E5%BC%8F%E5%90%AF%E5%8A%A8nodejs%E8%84%9A%E6%9C%AC/","content":"我们都知道，当我们以node server.js执行server.js服务脚本时，如果ctrl + c结束该进程，则对应的服务也就停止了，那如何以后台服务的形式执行该脚本呢？\n方法一 利用 foreverforever\n方法二 利用 pm2pm2\nnpm install -g pm2pm2 start server.js   // 启动pm2 stop server.js    // 停止pm2 list              // 列出所有服务，包括运行的和停止的pm2 delete server.js  // 删除该服务\n方法三 利用nodejs自带服务nohub，不需要安装别的包nohup node server.js &amp;// 存在无法查询日志等问题，关闭终端后服务也就关闭了","categories":["工具"],"tags":["pm2"]},{"title":"仿MacOS的后台管理系统","url":"/2023/01/13/%E4%BB%BFMacOS%E7%9A%84%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/","content":"前言目前比较流行的开源后台管理系统NG-ALAIN、Ant Design Pro、Vue-Element-Admin、Jeecg Boot等，其页面布局基本都是如下形式：诚然，这种形式并非不好，但看的多了，难免视觉疲劳。\n其实导航、菜单、Tab的设计，无非是为了用户能够更快捷的进入某个特性模块，而特性模块大多是相对独立的，如用户管理、资产管理、系统设置，可以近似看作是一个个独立的App。如果按照这个角度继续思考，那我们为什么不能参考操作系统的布局、交互，设计我们的系统、页面呢？而提到操作系统，MacOS无疑是翘楚之作，于是一款仿MacOS的后台管理系统的前端解决方案便应运而生了，暂且给它起个WebOS的名字吧。\n体验地址：https://doautumn.github.io/web-os\n\n该解决方案并未投入实战，只是用作学习与交流，欢迎感兴趣的小伙伴留言支持。\n\n技术实现技术栈：Angular13 + NG-ZORRO13\n1.基本布局基本布局部分比较简单，顶部MenuBar、中间Content、底部Dock。\n2.Window不管是MacOS还是Windows，都是以窗口来呈现应用程序内容的，用户也都习以为常。那如果在Web端也采用这种形式，效果将会如何呢？目前我也没有答案。不过我是持乐观态度的，而且我还为WebOS设计了一种键盘独占的交互模式（这将在下文讲到），我相信在这种模式的加持下，用户的满意度应该是比较高的。\n下面来聊一聊Window的具体实现方案。\n2.1 公开的属性、事件在做这种开发套件时，我一般首先考虑的是开发人员该如何使用我们提供的基础组件、服务。对于一个窗口而言，首先想到的需要开发人员干预的只有两项内容：title和content。进一步思考，当窗口处于非活动或最小化状态时，我们希望开发人员能够关注下性能，毕竟如果窗口打开过多，如何保证页面不卡顿将会是一件非常有必要的事情。为此我们需要提供两个状态切换事件：active和inactive，当窗口处于上述某种状态时，可以考虑暂停定时器、暂停持续的渲染动画等非必要的性能开销。对开发人员公开的内容除上述4项之外，还会有一些其他细节项，如minimizable（是否能够最小化）、maximizable（是否能够最大化）、style（默认位置尺寸）等。\n使用Window的伪代码：\n&lt;mz-window mzTitle=&quot;这是一个标题&quot; (active)=&quot;handleActive()&quot; (inactive)=&quot;handleInactive()&quot;&gt;  your code  ...&lt;/mz-window&gt;\n内部实现的伪代码：\n// window.component.ts@Component(&#123;  selector: &#x27;mz-window&#x27;,  templateUrl: &#x27;./window.component.html&#x27;,  styleUrls: [&#x27;./window.component.less&#x27;]&#125;)export class WindowComponent implements OnInit, OnDestroy &#123;  @Input() mzTitle: string;  @Input() minimizable: boolean = true;  @Input() maximizable: boolean = true;  @Input() style: any;  @Output() active = new EventEmitter();  @Output() inactive = new EventEmitter();&#125;// window.component.html&lt;div class=&quot;window&quot;&gt;  &lt;div class=&quot;title&quot;&gt;    &lt;span&gt;&#123;&#123; mzTitle &#125;&#125;&lt;/span&gt;  &lt;/div&gt;  &lt;div class=&quot;content&quot;&gt;    &lt;ng-content&gt;&lt;/ng-content&gt;  &lt;/div&gt;&lt;/div&gt;\n2.2 窗口的通用逻辑对于窗口的打开、关闭、最大化、最小化、拖拽、窗口切换等通用逻辑，都由框架统一实现即可。\n窗口与路由的关系\n而在实现上述功能之前，有一个关键问题需要解决。我们都知道，在基于Angular、Vue、React框架的前端工程中，开发一个中大型的后台管理系统，路由是不可或缺的基础功能。但正如前言中提到的，常见的开源后台管理系统，其主视区只显示当前路由对应的内容，如果我们在主视区想要显示多个窗口，是否意味着将不能再使用路由来组织我们的窗口？好在基于以往的开发经验，答案是否定的。在Angular、Vue中分别有对应的路由复用策略与keep-alive可以实现页面缓存（React貌似没有，好多年没用过了），我们可以借助此技术实现多个窗口的同时呈现。\n具体来讲，我们需要将路由和Window进行关联，也即一个Window对应一个路由（Window在初始化之后会暂存其对应的路由URL），同时开启路由复用，当切换路由时，将缓存的路由快照对应的视图层插入到主视区即可。\n非活动状态窗口的激活\n我们知道，在操作系统中点击非活动状态窗口的任意位置，都能使其处于活动状态，且不触发其内部逻辑，如下所示，点击Wiki并不会直接进入Wiki页面，而只是将浏览器前置使其处于活动状态。为了实现该效果，当窗口处于非活动状态时，给其设置一个透明遮罩层，点击窗口其实是点击的是遮罩层，触发的动作也仅仅只是路由的跳转，这也算是一个取巧的方案吧。\n窗口的最小化\n目前我们还没有实现MacOS最小化窗口的神奇动画效果的技术方案，暂且实现了缩放的动画效果，和MacOS类似，窗口缩放之后会以缩略图的形式暂存到Dock中。那如何生成窗口的缩略图呢？或者是否可以将窗口直接缩放至Dock中？经过综合考虑，我们希望窗口和Dock尽量是解耦的，所以还是采用了生成缩略图的方案，因为Dock本身也是支持设置图标的，这样只需创建一个Dock对象并将缩略图、窗口标题带上即可。new DockItem().init(&#123; name: title, iconPath: image, path: routePath &#125;)\n至于缩略图的生成，则是使用了html2canvas。\n3.DockDock的实现，有两个问题需要解决，一是单个应用程序图标（这里我们称之为DockItem吧）和Window的关联，二是丝滑的动画效果。\n关于DockItem和Window的关联，其实比较简单，上文已提到，Window和路由是一一对应的，那只需将DockItem和路由也做关联即可。只不过DockItem和路由并非一一对应，而是一个DockItem对应一个一级路由，包含若干个子路由。\n// 定义DockItem&#123;  &quot;apps&quot;: [    &#123;      &quot;name&quot;: &quot;VSCode&quot;,      &quot;iconPath&quot;: &quot;./assets/app-icons/vscode.svg&quot;,      &quot;path&quot;: &quot;demo1&quot;    &#125;,    &#123;      &quot;name&quot;: &quot;Webstorm&quot;,      &quot;iconPath&quot;: &quot;./assets/app-icons/webstorm.svg&quot;,      &quot;path&quot;: &quot;demo2&quot;    &#125;,    &#123;      &quot;name&quot;: &quot;Chrome&quot;,      &quot;iconPath&quot;: &quot;./assets/app-icons/chrome.svg&quot;,      &quot;path&quot;: &quot;demo3&quot;    &#125;  ]&#125;// 一级路由const routes: Routes = [  &#123;    path: &#x27;&#x27;,    component: WebOSLayoutComponent,    children: [      &#123;        path: &#x27;demo1&#x27;,        loadChildren: () =&gt; import(&#x27;./views/demo1/demo1.module&#x27;).then(m =&gt; m.Demo1Module)      &#125;,      &#123;        path: &#x27;demo2&#x27;,        loadChildren: () =&gt; import(&#x27;./views/demo2/demo2.module&#x27;).then(m =&gt; m.Demo2Module)      &#125;,      &#123;        path: &#x27;demo3&#x27;,        loadChildren: () =&gt; import(&#x27;./views/demo3/demo3.module&#x27;).then(m =&gt; m.Demo3Module)      &#125;    ]  &#125;];\n\n对于Dock丝滑的放大效果，这里实现的并不足够细致，就不详细阐述了，无非是动画处理scale、margin等样式，感兴趣的可以查看源码。另外，推荐下Steven实现的效果，很丝滑。\n如何使用计划将其作为基础开发包发布到npm，但由于还有一些功能暂未完成，如键盘独占、国际化等，故还需等待时日。\n","categories":["Angular"],"tags":["WebOS","后台管理系统"]},{"title":"使用Nexus托管npm私有仓库","url":"/2022/09/11/%E4%BD%BF%E7%94%A8Nexus%E6%89%98%E7%AE%A1npm%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93/","content":"1.安装Nexus1.1.前置条件nexus需要运行在jdk1.8及以上环境\n1.2.下载链接：https://pan.baidu.com/s/1r5x6flbkiTgI0MiJVrvq4Q，提取码：hsnr\n1.3.安装直接解压即可，解压后会有两个目录：\n\nnexus-3.18.1-01：nexus私服管理界面的容器，内部集成了jetty\nsonatype-work：私服的默认仓库，用于存储索引和组件资源\n\n1.4.启动进入nexus-3.18.1-01&#x2F;bin&#x2F;目录，./nexus run\n1.5.访问浏览器输入http://ip:8081\n1.6.登录默认用户名admin，会提示默认密码在安装包的什么位置windows虚拟机上的密码改为了Talent123\n1.7.Create repository其中，npm（hosted）可设置包的发布策略，是否允许重新发布，如果不允许重新发布，则每次发布包，均需升级版本号\n2.CentOS7下将Nexus设置为系统服务2.1.修改nexus启动脚本修改脚本第14行：INSTALL4J_JAVA_HOME_OVERRIDE=/root/jdk_1.8.0_231  // jdk安装路径否则，可能会出现以下错误：\n2.2.配置系统服务设置软连接：sudo ln -s /opt/nexus-3.18.1-01/bin/nexus /etc/init.d/nexus\n采用systemd的方式配置服务\ncd /etc/systemd/systemvi nexus.service在nexus.service文件中添加以下内容：[Unit]Description=nexus serviceAfter=network.target[Service]Type=forkingExecStart=/opt/nexus-3.18.1-01/bin/nexus start  #nexus的安装目录ExecStop=/opt/nexus-3.18.1-01/bin/nexus stopUser=root  #系统用户名Restart=on-abort[Install]WantedBy=multi-user.target\n\n分别执行以下命令：\nsudo systemctl daemon-reload #重新加载服务sudo systemctl enable nexus.service #开启开机自启动服务sudo systemctl start nexus.service #启动服务\n\n\n由于自己是在虚拟机上安装的，本机访问没有问题，但其他主机访问不到服务，故还需做如下配置：如何让局域网中的其他主机访问虚拟机\n","categories":["工具"],"tags":["Nexus","npm私服"]},{"title":"使用Vite构建Vue3组件库","url":"/2023/01/11/%E4%BD%BF%E7%94%A8Vite%E6%9E%84%E5%BB%BAVue3%E7%BB%84%E4%BB%B6%E5%BA%93/","content":"前言当我们使用Angular开发库项目时，直接通过ng g lib [name]在当前工作空间中创建一个新的通用库项目即可，Angular会帮我们把依赖、配置甚至打包命令都设置好，还是相当方便的。\n但当我们使用Vite + Vue3开发库项目时，该如何做呢？通过查Vite官方文档库模式发现，其介绍过于简单，因此这里做一个整理分享。\n开始一、初始化工程npm init vite@latest test1 --template vue-tsnpm i --save-dev path  // 后面vite.config.ts中会用到\n\n二、开发组件首先添加packages\\Button\\src\\MzButton.vue文件用于编写组件，内容如下：\n&lt;script setup lang=&quot;ts&quot;&gt;defineProps&lt;&#123; msg: string &#125;&gt;()&lt;/script&gt;&lt;template&gt;  &lt;div class=&quot;mz-button&quot;&gt;这是一个按钮：&#123;&#123; msg &#125;&#125;&lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt;.mz-button &#123;  padding: 10px;  border: solid 1px #5d5d5d;  border-radius: 3px;&#125;&lt;/style&gt;\n\n再添加packages\\Button\\index.js文件用于导出该组件，内容如下：\nimport MzButton from &#x27;./src/MzButton.vue&#x27;;MzButton.install = (App) =&gt; &#123;  App.component(MzButton.__name, MzButton);&#125;;export default MzButton;\n\n再添加packages\\index.js文件，用于导出所有的组件（这里其实只有一个组件，多组件只要在此基础上扩展即可），内容如下：\nimport MzButton from &#x27;./Button&#x27;;// 按需导入export &#123; MzButton &#125;;const components = [MzButton];const install = (App) =&gt; &#123;  components.forEach(item =&gt; &#123;    App.component(item.__name, item);  &#125;);&#125;;export default &#123;  install&#125;;\n\n三、配置vite.config.ts文件修改vite.config.js文件，对其进行配置修改成库打包的模式，这里输出内容到lib文件夹中，打包入口文件设置为./packages/index.js文件，最终配置如下所示：\nimport &#123; defineConfig &#125; from &#x27;vite&#x27;import vue from &#x27;@vitejs/plugin-vue&#x27;import &#123; resolve &#125; from &#x27;path&#x27;// https://vitejs.dev/config/export default defineConfig(&#123;  plugins: [vue()],  build: &#123;    outDir: &#x27;lib&#x27;,    lib: &#123;      entry: resolve(__dirname, &#x27;packages/index.js&#x27;),      name: &#x27;MzTest&#x27;,      // the proper extensions will be added      fileName: &#x27;mz-test&#x27;    &#125;,    rollupOptions: &#123;      // 确保外部化处理那些你不想打包进库的依赖      external: [&#x27;vue&#x27;],      output: &#123;        // 在 UMD 构建模式下为这些外部化的依赖提供一个全局变量        globals: &#123;          vue: &#x27;Vue&#x27;        &#125;      &#125;    &#125;  &#125;&#125;)\n\n四、打包输出lib库执行npm run build，根据上面的配置文件会在根目录生成一个lib文件夹，里面包含了UMD、ESM规范打包的几个js库文件，还有css样式文件，整个组件库文件最终都会输出在lib文件夹下。\n五、准备package.json配置package.json，内容如下（需要删除注释）：\n&#123;  &quot;name&quot;: &quot;mz-test&quot;,  &quot;private&quot;: false,  // 公开可下载  &quot;version&quot;: &quot;0.0.1&quot;,  &quot;keywords&quot;: [],  // 在npm上可被搜索的关键字  &quot;scripts&quot;: &#123;    &quot;dev&quot;: &quot;vite&quot;,    &quot;build&quot;: &quot;vue-tsc --noEmit &amp;&amp; vite build&quot;,    &quot;preview&quot;: &quot;vite preview&quot;  &#125;,  &quot;files&quot;: [&quot;lib&quot;],  &quot;main&quot;: &quot;lib/mz-test.umd.js&quot;,  // 包函数入口文件  &quot;module&quot;: &quot;lib/mz-test.js&quot;,    // ESM标准入口  &quot;exports&quot;: &#123;    &quot;./lib/style.css&quot;: &quot;./lib/style.css&quot;,    &quot;.&quot;: &#123;      &quot;import&quot;: &quot;./lib/mz-test.js&quot;,      &quot;require&quot;: &quot;./lib/mz-test.umd.js&quot;    &#125;  &#125;,  // 向外暴露的文件 node规范  &quot;dependencies&quot;: &#123;    &quot;vue&quot;: &quot;^3.2.37&quot;  &#125;,  &quot;devDependencies&quot;: &#123;    &quot;@vitejs/plugin-vue&quot;: &quot;^3.1.0&quot;,    &quot;vite&quot;: &quot;^3.1.0&quot;  &#125;&#125;\n\n在根目录添加一个.npmignore文件，其作用是忽略不需要上传的文件内容，内容如下：\n# Logslogs*.lognpm-debug.log*yarn-debug.log*yarn-error.log*pnpm-debug.log*lerna-debug.log*node_modulesdistdist-ssr*.local# Editor directories and files.vscode/*!.vscode/extensions.json.idea.DS_Store*.suo*.ntvs**.njsproj*.sln*.sw?packages/public/src/.gitignore.npmignore*.htmlpackage-lock.jsontsconfig.jsontsconfig.node.jsonvite.config.ts\n\n至此就可以将lib库上传至npm了。\n如果想要本地打包，则直接npm pack即可，这样就会在根目录下生成一个mz-test-0.0.1.tgz。\n使用组件一、安装组件npm i mz-test 或 npm i file:mz-test-0.0.1.tgz\n\n二、全局使用方法// main.tsimport &#123; createApp &#125; from &#x27;vue&#x27;import &#x27;./style.css&#x27;import App from &#x27;./App.vue&#x27;import MzTest from &#x27;mz-test&#x27;;  // 在ts文件中会报错，在vite-env.d.ts中添加declare module &#x27;mz-test&#x27;即可import &#x27;mz-test/lib/style.css&#x27;;createApp(App).use(MzTest).mount(&#x27;#app&#x27;)// 组件中&lt;mz-button&gt;&lt;/mz-button&gt; 或 &lt;MzButton&gt;&lt;/MzButton&gt;\n\n三、局部使用方法// main.tsimport &#x27;mz-test/lib/style.css&#x27;;// 组件中import &#123; MzButton &#125; from &#x27;mz-test&#x27;&lt;mz-button&gt;&lt;/mz-button&gt; 或 &lt;MzButton&gt;&lt;/MzButton&gt;","categories":["Vue"],"tags":["Vite","Vue3组件库"]},{"title":"使用nrm管理切换多个npm registry地址","url":"/2023/03/15/%E4%BD%BF%E7%94%A8nrm%E7%AE%A1%E7%90%86%E5%88%87%E6%8D%A2%E5%A4%9A%E4%B8%AAnpm-registry%E5%9C%B0%E5%9D%80/","content":"前言大家在工作时可能需要连接公司的私服下载前端依赖，这个时候会把npm的地址设置为公司的私服，但是这样的话自己开发自己的项目所需要的依赖在公司私服上找不到，因此又得重新设置npm下载的地址，因此在这推荐一个插件能够很方便的切换公司私服地址和淘宝镜像地址。\n一、nrmnrm（npm registry manager）是npm的镜像管理工具，用来切换npm下载镜像源\n二、使用步骤1、安装nrmnpm i -g nrm\n安装之后，可通过nrm ls查看默认提供的镜像源\nnpm ---------- https://registry.npmjs.org/yarn --------- https://registry.yarnpkg.com/tencent ------ https://mirrors.cloud.tencent.com/npm/cnpm --------- https://r.cnpmjs.org/taobao ------- https://registry.npmmirror.com/npmMirror ---- https://skimdb.npmjs.com/registry/\n\n2、添加registrynrm add topsec http://10.63.78.76/repository/npm-group/// topsec 为自定义名称// 成功将会提示：add registry topsec success\n\n3、切换registrynrm use topsec// 成功将会提示：Registry has been set to: http://10.63.78.76/repository/npm-group/","categories":["工具"],"tags":["nrm","npm源管理"]},{"title":"使用nvm管理切换多个node版本","url":"/2023/03/10/%E4%BD%BF%E7%94%A8nvm%E7%AE%A1%E7%90%86%E5%88%87%E6%8D%A2%E5%A4%9A%E4%B8%AAnode%E7%89%88%E6%9C%AC/","content":"1、Node版本管理工具node版本管理工具其实有很多，常见的的有nvm、n、fnm。之前一直使用n来管理node版本的，但是忽然有一天发现，安装n之前是需要先安装node的，而先安装的这一版本的node，不在n的管理范畴中，基于这两点原因，放弃了n的使用，转向了nvm。本文主要记录下nvm的安装步骤和常用命令。\n2、nvm的安装网上关于nvm安装的文章也挺多的，大多都是让你执行\ncurl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.3/install.sh | bash\n包括Github上也是这么写的，但一般由于网络原因，都是不能成功的，即便我开了科学上网，也没能成功。所以建议：直接从上述Github仓的Tags里，下载最新版本的zip包，解压之后，运行包里的install.sh即可。然后将如下代码粘贴到你的～/.base_profile文件中，保证nvm命令能够正常使用。\nexport NVM_DIR=&quot;$([ -z &quot;$&#123;XDG_CONFIG_HOME-&#125;&quot; ] &amp;&amp; printf %s &quot;$&#123;HOME&#125;/.nvm&quot; || printf %s &quot;$&#123;XDG_CONFIG_HOME&#125;/nvm&quot;)&quot;[ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;&amp; \\. &quot;$NVM_DIR/nvm.sh&quot; # This loads nvm\n\n3、nvm常用命令nvm ls                #列出已安装的node版本nvm ls-remote         #列出所有可用的node版本nvm use &lt;version&gt;     #使用指定版本的nodenvm install &lt;version&gt; #安装指定版本的nodenvm current           #显示当前正在使用的node版本nvm cache clear       #清空nvm缓存\n\n","categories":["工具"],"tags":["nvm","Node版本管理"]},{"title":"关于commitlint和husky的安装和使用","url":"/2023/01/11/%E5%85%B3%E4%BA%8Ecommitlint%E5%92%8Chusky%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/","content":"现在大部分公司和项目用的代码管理工具基本都是git，在一个大的项目组中，会涉及很多的开发人员，这就会面临着频繁的提交代码。规范的提交代码规则会有利于问题的查找和回归，所以提交规范变得尤其的重要。下面我会为大家介绍一下，关于git的代码提交规则的约束工具：commitlint和husky。\n\n\n一、commitlint 链接1、安装npm i -D @commitlint/cli @commitlint/config-conventional\n2、生成commitlint配置文件项目根目录下执行：\necho &quot;module.exports = &#123;extends: [&#39;@commitlint/config-conventional&#39;]&#125;&quot; &gt; commitlint.config.js\n可以在这个文件里设置自定义的git提交message的规则。\n3、常用的commit message的类型feat - A new feature.fix - A bug fix.docs - Documentation only changes.style - Changes that do not affect the meaning of the code (white-space, formatting, missing semi-colons, etc).refactor - A Code change that neither fixes a bug nor adds a feature.pref - A code change that improves performance.test - Adding missing tests or correcting existing tests.build - Changes that effect the build system or external dependencies (example scopes: glup, broccoli, npm).ci - Changes to our CI configuration files and scripts (example scopes: Travis, Circle, , BrowserStack, SauceLabs).chore - Other changes that don’t modify sc or test files.revert - Reverts a previous commit.\n二、husky 链接husky可以让我们向项目中方便添加git hooks。\n1、安装npm i -D husky\n2、编辑package.json &gt; prepare 脚本并运行npm pkg set scripts.prepare=&quot;husky install&quot;npm run prepare\n此时会在项目根目录下创建一个.husky目录后续，当别人clone了你的仓(意味着项目根目录下有.git目录)，并执行npm install(无参数)时，husky install命令会自动执行\n3、添加一个钩子npx husky add .husky/commit-msg &#39;npx --no-install commitlint --edit &quot;$1&quot;&#39;\n此时会在.husky目录下创建一个commit-msg文件\n4、测试git commit -m &quot;新增了一个xxx功能&quot;这样的commit message将会直接报错git commit -m &quot;feat(scope?): 新增了一个xxx功能&quot;这样规范的commit message是被允许的\n三、根据commit message自动生成changelog1、安装依赖npm i -D conventional-changelog conventional-changelog-cli\n2、编辑package.json &gt; changelog 脚本npm pkg set scripts.changelog=&quot;conventional-changelog -p angular -i CHANGELOG.md -s&quot;\n各参数含义：-p Name of the preset you want to use. Must be one of the following: angular, atom, codemirror, ember, eslint, express, jquery, jscs or jshint-i Read the CHANGELOG from this file-s Outputting to the infile so you don’t need to specify the same file as outfile-r How many releases to be generated from the latest. If 0, the whole changelog will be regenerated and the outfile will be overwritten. Default: 1\n更详细的参数说明请查看这里\n3、生成changelog运行命令即可生成changelog\nnpm run changelog\n\n最后附上一个开源项目https://github.com/ng-docs/awesome-angular，关于husky的使用，即是从这里学到的。另外，作者还用到了prestart、prebuild钩子，实现了启动、打包项目之前的一些校验工作。还有，作者还通过nodejs实现了获取文件git提交历史等的相关信息。后续如果有需要，可以参考。\n","categories":["Git"],"tags":["git hooks","commitlint","husky"]},{"title":"前端自动部署脚本","url":"/2024/01/03/%E5%89%8D%E7%AB%AF%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2%E8%84%9A%E6%9C%AC/","content":"当一套前端代码需要根据配置打包成不同版本且部署到不同环境时，如果还是手动完成这些事情，这无疑是非常浪费时间的。这个时候自动打包、自动部署脚本就应运而生了。\n前端NodeJS、Angular13\n需求一套前端代码，打包时可以选择企业版、企业版深色、社区版、社区版深色等版本，部署时可以选择01、02、03、04等环境\n自动打包对于 当执行打包、部署命令时 提示版本选择、环境选择这一功能，可以使用Linux脚本实现，也可以使用inquirer实现。但由于inquirer是基于node，意味着选择版本之后也需要使用nodejs代码启动打包命令ng build，虽然能够通过child_process（具体可参考这里）实现，但经过测试，不能输出打包日志，所以放弃了这种方案，改用Linux脚本实现。\n#!/bin/bashPS3=&quot;请选择版本: &quot;    options=(&quot;Enterprise&quot; &quot;Enterprise-Dark&quot; &quot;Community&quot; &quot;Community-Dark&quot;)        selected=&quot;&quot;  # 初始化selected变量    select opt in &quot;$&#123;options[@]&#125;&quot;; do        selected=&quot;$opt&quot;  # 将选中的项赋值给selected变量      case $opt in            &quot;Enterprise&quot;)                # echo &quot;你选择了Enterprise&quot;                break            ;;            &quot;Enterprise-Dark&quot;)                # echo &quot;你选择了Enterprise-Dark&quot;                break                ;;            &quot;Community&quot;)                # echo &quot;你选择了Community&quot;                break                ;;            &quot;Community-Dark&quot;)                # echo &quot;你选择了Community-Dark&quot;                break                ;;            *) echo &quot;无效的选项&quot;;;        esac    done    echo &quot;你选择的版本是: $selected&quot;  # 打印出selected变量的值rm -rf ./dist/ui.zip ./dist/admin.zip# 先打包后台管理界面ng build admin --base-href=/admin/ --configuration=$selected# 再打包前端界面ng build --configuration=$selectedcd dist# 将后台管理界面拷贝到前端界面目录下(服务器通过Nginx代理到不同界面)mv admin ui/zip -qr ui.zip ui/\n\n对于Angular工程，我们可以通过在environments/environment.ts中自定义变量的方式控制不同的版本，形如这样：\nexport const environment = &#123;  production: false,  versionType: &#x27;Enterprise-Dark&#x27;&#125;;\n但是在打包时如何更改versionType的值呢？是不是可以这样ng build --env.versionType=xxx？很遗憾，Angular CLI并不支持这样，ng build的参数是不能自定义的。虽然这样，我们仍然可以通过如下两种方式达到目的：\n\n在ng build之前通过nodejs读写文件的方式更改environments/environment.prod.ts中versionType的值\n通过配置angular.json中的configurations，然后指定ng build --configuration=xxx来控制打包时使用哪个配置信息即可，形如这样：&quot;configurations&quot;: &#123;  &quot;Enterprise&quot;: &#123;    &quot;fileReplacements&quot;: [      &#123;        &quot;replace&quot;: &quot;src/environments/environment.ts&quot;,        &quot;with&quot;: &quot;src/environments/environment.enterprise.ts&quot;      &#125;    ],    &quot;outputHashing&quot;: &quot;all&quot;  &#125;,  &quot;Enterprise-Dark&quot;: &#123;    &quot;fileReplacements&quot;: [      &#123;        &quot;replace&quot;: &quot;src/environments/environment.ts&quot;,        &quot;with&quot;: &quot;src/environments/environment.enterprise-dark.ts&quot;      &#125;    ],    &quot;outputHashing&quot;: &quot;all&quot;  &#125;,  &quot;Community&quot;: &#123;    &quot;fileReplacements&quot;: [      &#123;        &quot;replace&quot;: &quot;src/environments/environment.ts&quot;,        &quot;with&quot;: &quot;src/environments/environment.community.ts&quot;      &#125;    ],    &quot;outputHashing&quot;: &quot;all&quot;  &#125;,  &quot;Community-Dark&quot;: &#123;    &quot;fileReplacements&quot;: [      &#123;        &quot;replace&quot;: &quot;src/environments/environment.ts&quot;,        &quot;with&quot;: &quot;src/environments/environment.community-dark.ts&quot;      &#125;    ],    &quot;outputHashing&quot;: &quot;all&quot;  &#125;&#125;\n\n自动部署自动部署也是有两种方案：sshpass和node-ssh。\n\nsshpass\n\n#!/bin/bashserver=&quot;&quot;username=&quot;&quot;password=&quot;&quot;sshpass -p $password scp ./dist/ui.zip $username@$server:/data/app/sshpass -p $password ssh $username@$server &#x27;cd /data/app/; sh ui_update.sh&#x27;\n这种方案在基于Intel芯片的Mac上测试成功了，但是在搭载Apple芯片的Mac上执行不成功，暂时不知道什么原因。\n\nnode-ssh\n\nconst path = require(&#x27;path&#x27;)//引入模块const inquirer = require(&#x27;inquirer&#x27;)// 询问消息npm install --save inquirer@^8.0.0const ora = require(&#x27;ora&#x27;)// 加载动画ora6.0以上版本不支持require方式引入，如果在node中使用，需要使用5.0版本const &#123; NodeSSH &#125; = require(&#x27;node-ssh&#x27;)//链接ssh模块const util = require(&#x27;./util&#x27;)//引入样式const ssh = new NodeSSH()//创建实例sshvar configGlobal// 声明环境对象在选择部署环境时赋值// 连接到服务器async function connectServer() &#123;  const spinner = ora(&#x27;登录服务器中...\\n&#x27;)  spinner.start()  ssh.connect(configGlobal.config)    .then(() =&gt; &#123;      spinner.stop()      util.green(&#x27;SSH登录成功&#x27;)      mvRemoteFile()    &#125;).catch((err) =&gt; &#123;      spinner.stop()      util.red(&#x27;SSH登录失败:\\n&#x27;, err)    &#125;)&#125;// 备份远程文件async function mvRemoteFile() &#123;  await ssh.execCommand(    `mv ui.zip ui_$&#123;util.nowDate()&#125;.zip`,    &#123; cwd: configGlobal.remoteFileRoot &#125;  ).then(() =&gt; &#123;    util.green(&#x27;远程文件 ui.zip 备份成功&#x27;)    rmRemoteFile()  &#125;)&#125;// 删除远程文件ui.zipasync function rmRemoteFile() &#123;  await ssh.execCommand(    `rm -rf ui`,    &#123; cwd: configGlobal.remoteFileRoot &#125;  ).then(() =&gt; &#123;    util.green(&#x27;远程文件 ui 删除成功&#x27;)    uploadFile()  &#125;)&#125;// 上传文件到服务器async function uploadFile() &#123;  const spinner = ora(&#x27;上传文件到服务器...\\n&#x27;)  spinner.start()  await ssh.putFile(`$&#123;path.join(process.cwd())&#125;/dist/ui.zip`, `$&#123;configGlobal.remoteFileRoot&#125;ui.zip`)    .then(() =&gt; &#123;      spinner.stop()      util.green(&#x27;本地文件 ui.zip 上传成功&#x27;)      unzipRemoteFile()    &#125;).catch((err) =&gt; &#123;      spinner.stop()      util.red(&#x27;本地文件 ui.zip 上传失败:\\n&#x27;, err)    &#125;)&#125;// 解压远程文件ui.zipasync function unzipRemoteFile() &#123;  await ssh.execCommand(    `unzip ui.zip`,    &#123; cwd: configGlobal.remoteFileRoot &#125;  ).then(() =&gt; &#123;    util.green(&#x27;远程文件 ui.zip 解压成功&#x27;)    configGlobal.restart ? execRemoteShell() : end()  &#125;)&#125;// 执行远程命令async function execRemoteShell() &#123;  const spinner = ora(&#x27;服务重启中...\\n&#x27;)  spinner.start()  await ssh.execCommand(    `sh restart.sh`,    &#123; cwd: configGlobal.remoteFileRoot &#125;  ).then(() =&gt; &#123;    util.green(&#x27;服务重启成功&#x27;)    end()  &#125;)&#125;function end() &#123;  util.green(&#x27;UI部署完成&#x27;)  ssh.dispose()&#125;const username = &#x27;&#x27;, password = &#x27;&#x27;const envSetting = [  &#123;    envName: &#x27;01环境&#x27;,    remoteFileRoot: &#x27;/data/app/&#x27;,    config: &#123;      host: &#x27;&#x27;,      port: 22,      username: username,      password: password    &#125;  &#125;,  &#123;    envName: &#x27;02环境&#x27;,    remoteFileRoot: &#x27;/data/app/&#x27;,    config: &#123;      host: &#x27;&#x27;,      port: 22,      username: username,      password: password    &#125;  &#125;,  &#123;    envName: &#x27;03环境&#x27;,    remoteFileRoot: &#x27;/data/app/&#x27;,    config: &#123;      host: &#x27;&#x27;,      port: 22,      username: username,      password: password    &#125;,    restart: true  &#125;,  &#123;    envName: &#x27;04环境&#x27;,    remoteFileRoot: &#x27;/data/app/&#x27;,    config: &#123;      host: &#x27;&#x27;,      port: 22,      username: username,      password: password    &#125;,    restart: true  &#125;];// 启动  自执行函数(async function () &#123;  const choices = envSetting.map(item =&gt; &#123;    return item.envName  &#125;)  inquirer.prompt([    &#123;      type: &#x27;list&#x27;,      message: &#x27;请选择部署环境：&#x27;,      name: &#x27;environment&#x27;,      default: &#x27;&#x27;,      // 前缀      prefix: &#x27;☆&#x27;,      // 后缀      suffix: &#x27;&#x27;,      choices    &#125;  ]).then(res =&gt; &#123;    configGlobal = envSetting[choices.indexOf(res.environment)]    connectServer()  &#125;)&#125;)()\n.&#x2F;util.js代码如下：\nexports.underLine = (value) =&gt; &#123;  console.log(`\\u001b[21m$&#123;value&#125;\\u001b[0m`);&#125;exports.gray = (value) =&gt; &#123;  console.log(`\\u001b[30m$&#123;value&#125;\\u001b[0m`);&#125;exports.red = (value) =&gt; &#123;  console.log(`\\u001b[31m$&#123;value&#125;\\u001b[0m`);&#125;exports.green = (value) =&gt; &#123;  console.log(`\\u001b[32m$&#123;value&#125;\\u001b[0m`);&#125;exports.yellow = (value) =&gt; &#123;  console.log(`\\u001b[33m$&#123;value&#125;\\u001b[0m`);&#125;exports.blue = (value) =&gt; &#123;  console.log(`\\u001b[34m$&#123;value&#125;\\u001b[0m`);&#125;exports.purple = (value) =&gt; &#123;  console.log(`\\u001b[35m$&#123;value&#125;\\u001b[0m`);&#125;exports.blueSky = (value) =&gt; &#123;  console.log(`\\u001b[36m$&#123;value&#125;\\u001b[0m`);&#125;exports.white = (value) =&gt; &#123;  console.log(`\\u001b[37m$&#123;value&#125;\\u001b[0m`);&#125;exports.nowDate = () =&gt; &#123;  const now = new Date();  const year = now.getFullYear();  const month = now.getMonth() + 1;  const today = now.getDate();  return year + fillZero(month) + fillZero(today);&#125;function fillZero(str) &#123;  return str &lt; 10 ? &#x27;0&#x27; + str : &#x27;&#x27; + str;&#125;","categories":["工具"],"tags":["inquirer","node-ssh","sshpass"]},{"title":"可视化技术选型","url":"/2022/07/16/%E5%8F%AF%E8%A7%86%E5%8C%96%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/","content":"架构对比\nBS 架构：Unity、WebGL、Threejs\nCS 架构：Unity、UE4、Ventuz\n因为 Ventuz 是国外收费引擎，因此下面内容不做对比。\n\n效果对比\nCS 架构优于 BS 架构。\nCS 架构中，UE4 和 Unity 效果各有特色，UE4 写实效果优于 Unity，Unity 其他效果优于 UE4。\nBS 架构：Unity 的 B 端效果要优于 WebGL 和 Threejs，WebGL 和 Threejs 效果基本差不多。\n\n体量对比\nUE4 体量是这几个技术中最大的，相对于 Unity，UE4 的安装包 10GB 左右，同时对开发设备要求也是最高的，相同的项目等级，UE4 项目的体量要大于 Unity。\nBS 架构因为效果低于 CS 架构，因此体量相对较小。\n\n开发对比\nBS 架构中 WebGL 和 Threejs 因为没有成熟的渲染流程，开发工作量比较大，但是 Unity 的 WebGL 是基于 Unity 引擎渲染，有成熟的渲染流程，开发工作量比较小；举个例子，在场景中增加一个相机，WebGL 和 Threejs 需要手动敲代码增加一个相机，而 Unity 只需要拖一个相机组件到场景即可。前两者使用 JS 语言，后面的 Unity 使用 C# 语言，最后发布成 WebGL。\n相比 WebGL 和 Threejs，Unity 开发 B 端，主要工作是场景设计以及开发部分，不需要关心模型导入等其他问题。\nCS 架构中，UE4 使用 C++ 语言开发，Unity 使用 C# 语言开发，UE4 的 C++ 语言也是在原 C++ 语言上增加的反射机制，因此编译比较慢；C# 语言是面向对象语言，有反射机制，因此开发过程中编译比较快。\n扩展性：Unity 要优于 UE4，毕竟 C# 语言是面向对象的语言，市面上 Unity 的插件是要多于 UE4 的插件。这个从腾讯选择 Unity 做自己产品就可以看出。\n\n友好对比\n这里不做 B 端的阐述，相对 C 端，B 端的友好度很低。\nUE4 的界面给人一种比较乱的感觉，画面跳色太多；在编辑材质、模型等资源时，会重新打开一个窗口，造成多个窗口来回拖动，影响操作性。\nUnity 的界面友好度要优于 UE4，Unity 的所有窗口都在同一个大窗口之下，一目了然的可以看到各个窗口的内容。\n\n渲染对比\n因为 C 端效果要优于 B 端，因此不做 B 端阐述。\nUnity 是实时渲染，当修改材质时，可以实时看到场景内物体上材质的改变。\n但是 UE4 修改材质时，需要保存并编译后才能看到，编译过程耗费的时间也跟使用的设备配置有关。\n\n平台对比\nUnity 可以发布成 B 端、C 端、移动端等\nUE4 可以发布成 C 端、移动端等\n\n维护对比Unity 的项目维护成本要低于 UE4 的维护成本，这个维护成本是从人力、设备等多方面考虑，一个相同体量项目，UE4 技术比 Unity 技术要多 1~2 个人。\n发布对比以相同项目发布成 C 端为例，UE4 耗费的时间要高于 Unity，具体是多少要看项目大小。\n像素流技术现在 UE4 和 Unity 都有像素流技术，像素流的原理是将服务器渲染的画面通过视频流的方式传递至客户端，客户端不做渲染工作。因为是视频流，所以对网络带宽是有要求的，当然务器成本就很高。\n","categories":["可视化"]},{"title":"如何将透明度应用于CSS变量","url":"/2024/06/04/%E5%A6%82%E4%BD%95%E5%B0%86%E9%80%8F%E6%98%8E%E5%BA%A6%E5%BA%94%E7%94%A8%E4%BA%8ECSS%E5%8F%98%E9%87%8F/","content":"当我们使用CSS变量开发页面主题时，难免遇到这样的场景，假设有一个主色--primary-color: #2a8b92;，在某些地方想使用透明度为0.5的主色、0.8的主色。。。这个时候该怎么办呢？在这之前，我只能定义多个主色变量：\n:root &#123;  --primary-color: #2a8b92;  --primary-color-opacity-05: rgba(42, 139, 146, 0.5);  --primary-color-opacity-08: rgba(42, 139, 146, 0.8);  --primary-color-opacity-10: rgba(42, 139, 146, 1);&#125;\n这样一来，需要维护的变量就太多了，好在CSS变量支持如下写法：\n:root &#123;  --primary-color: 42, 139, 146;&#125;\n使用时只需这样即可：\n.element &#123;  background: rgba(var(--primary-color), 0.5);  border-color: rgba(var(--primary-color), 1);&#125;\n但这样每次使用时都需要写rgb或rgba，略微麻烦，所以一般可以这样：\n:root &#123;  --primary-color-rgb: 42, 139, 146;  --primary-color-hex: #2a8b92;&#125;\n这样当需要透明度时使用--primary-color-rgb，当不需要透明度时直接使用--primary-color-hex\n.element &#123;  background: rgba(var(--primary-color-rgb), 0.5);  border-color: var(--primary-color-hex);&#125;","categories":["CSS"],"tags":["CSS变量"]},{"title":"富文本编辑器调研","url":"/2023/09/01/%E5%AF%8C%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8%E8%B0%83%E7%A0%94/","content":"超实用开源License基础知识扫盲帖（下）GPL、MIT、Apache…一文讲清楚开源协议间的区别\n\n\n\n名称\n介绍\n是否开源\n备注\n\n\n\n\nAIEditor\nAiEditor 是一个面向 AI 的下一代富文本编辑器，它基于 Web Component 开发，因此支持 Layui、Vue、React、Angular、Svelte 等几乎任何前端框架。她适配了 PC Web 端和手机端，并提供了 亮色 和 暗色 两个主题。除此之外，她还提供了灵活的配置，开发者可以方便的使用其开发任何文字编辑的应用。—— 摘自官方文档\nLGPL-2.1 license只需要开源直接调用LGPL库的那部分代码\n中英文文档开源版可直接使用浏览源码发现是基于 Tiptap 的二次开发\n\n\nTinyMCE\nTinyMCE是一个开源的所见即所得的HTML编辑器，界面相当清新，界面模拟本地软件的风格，顶部有菜单栏。支持图片在线处理，插件多，功能非常强大，易于集成，并且拥有可定制的主题。支持目前流行的各种浏览器，它可以达到微软Word类似的编辑体验。而且这么好的东西还是开源免费的，目前一直有人维护，这款编辑器使用的人非常多。\nMIT license\n英文文档中文文档地址提供支持Angular的依赖包\n\n\nCKEditor5\nCKEditor也是一款非常经典的富文本编辑器，官方下载量过千万。它是在非常著名的FCKEditor基础上开发的新版本，FCKEditor的用户现在基本都转移到CKEditor了。CKEditor有高性能的实时预览，它特有行内编辑功能，使得编辑内容更加直观，仿佛是在编辑网页一样，有很强的可扩展性，被各大网站广泛运用。\nGNU General Public License要求使用者必须开源\n英文文档提供支持Angular的依赖包\n\n\nTiptap\nTiptap 编辑器是一个无头、与框架无关的富文本编辑器，可以通过扩展程序进行自定义和扩展。无头性质意味着 Tiptap 没有固定的用户界面，提供完全的设计自由。Tiptap 是基于 ProseMirror 开发的，而 ProseMirror 则是一个用于构建所见即所得富文本编辑器的工具包。目前有4种定价方式：免费版、入门版（149美元/月）、商业版（999美元/月）、企业版（Custom）\nMIT License\n英文文档\n\n\nwangEditor\nwangEditor轻量级，小巧实用，配置方便，使用简单。可以自定义皮肤功能，免费开源。用户数量也很多，尤其是用在一些轻型环境，比如论坛社区回帖。wangEditor是国人出品的开源项目。wangEditor 是基于 Slate 开发的。bug较多，这都是其官方示例中存在的bug：1. 编辑器必须设置高度，无法实现类似腾讯文档纵向无限延伸的效果，如果不设置高度，则当内容只有一行时，hoverbar位置不对2. 插入分隔线或表格或自定义元素时，总是会在前面空出一行，哪怕光标所在行没有任何内容3. 在分割线上方插入表格，表格却跑到了分割线下方，两个互换了位置\nMIT license\n中文文档\n\n\nFroala Editor\nFroala是一款功能丰富的富文本编辑器，界面分类清晰，容易集成，容易升级，支持主流浏览器，具有行内编辑功能。Froala代码示例很多，可以集成在很多js框架里如React.js，Aurelia，Angular，Ionic，Django等。插件很多，易于扩充功能。Froala是收费的，不过前端是开源的，如果要使用后台是要交费的（如果你使用国人强大的crack技能那就是另外一回事了~ ~）。目前有三个定价方式：免费版、专业版（629美元/年）和企业版（1399美元/年）。\nLicense DetailThe angular-froala-wyswiyg project is under MIT license. However, in order to use Froala WYSIWYG HTML Editor plugin you should purchase a license for it.\n英文文档提供支持Angular的依赖包\n\n\nQuill\nQuill是轻型的编辑器，样式一般（黑白风），功能中等，它的代码高亮功能比较强，同样支持行内编辑模式，工具条可自定义。开源免费，项目活跃，一直有人维护。\nBSD-3-Clause license和 MIT 协议区别不大\n看Github代码是有在更新，但最新的Tag是2019年的。官网文档太过简单。不太推荐在 2024.04 发布了 V2.0.0 版本不过相比 AIEditor 这种开箱即用的体验，Quill 似乎仍旧不是一个很好的选择\n\n\nbootstrap-wysiwyg\nbootstrap-wysiwyg是基于Bootstrap的轻型、免费开源的富文本编辑器，界面简洁大方。使用需要先引入Bootstrap。个人觉得bootstrap-wysiwyg这一长串像乱码一样的名字影响了它的推广和使用~ ~毕竟轻型使用环境还是很多的。\n\n依赖jQuery、Bootstrap，不推荐使用\n\n\nSummernote\nSummernote是一款轻量级的富文本编辑器，比较容易上手，使用体验流畅，支持各种主流浏览器。Summernote开源免费，该项目一直比较活跃，一直都有人在维护。\n\n依赖jQuery、Bootstrap，不推荐使用\n\n\nDHTMLX Rich Text Editor\nDHTMLX组件是一整套基于JS的UI库，功能强大，其中包含编辑器dhtmlxEditor。该编辑器可以直接集成到Angular，React和Vue.js框架中，该编辑器还同时支持Markdown和富文本。支持普通视图和类似word一样的页面视图，支持全屏幕，工具支持自定义，包括工具条颜色和样式等。\n\n收费\n\n\nKindEditor\nKindEditor历史也很长了，用户数也不少，国内某公司出品。免费开源。界面类似于office word，界面和功能中规中矩，文档齐全，使用还算方便。\n\n界面比较老气，应该是win xp时代的产物，不推荐使用\n\n\nFreeTextBox\nFreeTextBox功能强大，前端支持主流浏览器，但后台只支持.NET。它的外观和使用风格都和微软 Word很类似。工具条可以定制，运行速度一般。FreeTextBox分为免费版和pro收费版，一般情况免费版本功能已经足够用了。\n\n界面比较老气，应该是win xp时代的产物，不推荐使用\n\n\neWebEditor\neWebEditor外观和使用风格都和微软 Word很类似，功能很多。工具条可以定制，运行速度很快。导入文件接口很多，支持word、excel、pdf、ppt直接导入，目前版本不支持代码高亮，不适合纯技术平台使用，适合内容编辑人员使用。eWebEditor有很长的历史了，是典型的传统富文本编辑器，不论是界面，还是功能都比较传统。eWebEditor是收费的，但也有免费的精简版，精简版没有后台功能。\n\n界面比较老气，应该是win xp时代的产物，不推荐使用\n\n\nUEditor\nUEditor 是由百度出品的富文本web编辑器，具有轻量，可定制，注重用户体验等特点，开源免费。这款编辑器用过的人也非常多，功能非常全面，插件很多，还可以很方便插入百度地图，接入十分简单。16年之后百度没有怎么更新了，不过现有的功能也足够用了。UEditor分为UE版（全功能版）和UM版（精简版），大家可以根据自己使用环境选择不同的版本。\n\n停更，不推荐使用\n\n\nSimditor\nSimditor是Tower平台使用的富文本编辑器，是一款轻量化的编辑器，界面简约，功能实用，插件不是很多，功能要求不高的可以使用。虽然是国内出品，但文档是英文的。开源免费。\n\n停更（最新的Tag是2019年的），不推荐使用\n\n\n","categories":["富文本编辑器"],"tags":["富文本编辑器","License"]},{"title":"微前端之Angular应用方案","url":"/2024/11/08/%E5%BE%AE%E5%89%8D%E7%AB%AF%E4%B9%8BAngular%E5%BA%94%E7%94%A8%E6%96%B9%E6%A1%88/","content":"什么是微前端\nTechniques, strategies and recipes for building a modern web app with multiple teams that can ship features independently. – Micro Frontends微前端是一种多个团队通过独立发布功能的方式来共同构建现代化 web 应用的技术手段及方法策略。\n\n微前端架构具备以下几个核心价值：\n\n技术栈无关主框架不限制接入应用的技术栈，微应用具备完全自主权\n独立开发、独立部署微应用仓库独立，前后端可独立开发，部署完成后主框架自动完成同步更新\n增量升级在面对各种复杂场景时，我们通常很难对一个已经存在的系统做全量的技术栈升级或重构，而微前端是一种非常好的实施渐进式重构的手段和策略\n独立运行时每个微应用之间状态隔离，运行时状态不共享\n\n微前端架构旨在解决单体应用在一个相对长的时间跨度下，由于参与的人员、团队的增多、变迁，从一个普通应用演变成一个巨石应用(Frontend Monolith)后，随之而来的应用不可维护的问题。这类问题在企业级 Web 应用中尤其常见。\n更多关于微前端的相关介绍，推荐大家可以去看这几篇文章：\n\nMicro Frontends\nMicro Frontends from martinfowler.com\n可能是你见过最完善的微前端解决方案\n微前端的核心价值\n\n\n举一个具体的例子，假如一个 Web 应用有 N 多个功能模块，比如有数据管理、大屏配置、流程编辑、安全报告，每个模块自身其实已经很复杂了，如果放到一个工程里，并且是由一个团队负责，那倒也问题不大，顶多就是打包慢一点。但如果是由不同的团队负责，并且每个模块又需要独立发布，独立部署，那么这种情况下，微前端架构就显得尤为重要了。\n在了解到微前端架构之前，我们甚至尝试过将各个功能模块构建为依赖包，然后由一个独立的、类似 Portal 的工程安装这些依赖包，通过路由来加载这些模块。这种方案虽然能够在开发态将各个模块独立开来，但在生产环境其实还是将所有模块打包到一起了，倘若一个模块出现问题，还是需要将所有模块一并打包更新，独立发布、部署的核心问题还是没有解决。\nqiankun\n可能是你见过最完善的微前端解决方案🧐\n\n关于 qiankun 的使用，有机会再去整理。\nPlanet\nAngular 框架下无懈可击的微前端框架和一体化解决方案\n\n由于公司的技术栈是 Angular，所以选择了它。对于较早版本(如@worktile&#x2F;planet@12、@worktile&#x2F;planet@13)，他们团队并没有提供链接中如此详细的帮助网站，只能依赖 README 和源码摸索使用，中间踩了不少坑，所以记录下早期版本的使用步骤。\n这里以 Angular@13 为例，使用 Angular CLI 初始化工程。\n一、初始化工程并安装相关依赖ng new portal --routing -S -g --style=lessng g app1 --routing -S --style=less  // Angular 本身支持在一个工程中创建多个应用，这里的 app1 app2 为子应用名称，后面会用到ng g app2 --routing -S --style=lessnpm i @worktile/planet@13 --savenpm i @angular-builders/custom-webpack@13 webpack-assets-manifest@5 --save-dev\n\n二、主应用配置1. 标记是否为集成环境我们期望子应用在开发时，能够独立运行，能够显示各自子模块对应的导航菜单，比如数据管理子应用，还包含数据库管理、文件系统管理等，在本地开发时，如果只能通过地址栏输入 URL 切换页面，那就太麻烦了。\n而当子应用被 Portal 集成时，子应用的导航菜单将不再显示，而是由 Portal 统一提供。所以我们需要一种方式，让子应用知道当前是否被集成到 Portal 中，从而决定是否显示导航菜单。\n为此，我们在 Portal 中创建一个全局变量 window.__POWERED_BY_PLANET__，值为 true，表示当前是集成环境。当子应用开始运行时，通过该变量判断当前环境，从而决定是否显示导航菜单（子应用单独启动时是获取不到该变量的，因为它是在 Portal 中定义的）。\n// src/main.ts...(window as any).__POWERED_BY_PLANET__ = true;platformBrowserDynamic().bootstrapModule(AppModule)  .catch(err =&gt; console.error(err));\n2. 配置路由@worktile/planet 采用主应用和子应用互相同步路由的方式实现页面切换，当进入子应用路由时，主应用其实是没有对应的路由信息的，所以需要导航到空白页面，然后由子应用接管路由显示对应的页面。\n// src/app/app.module.ts...const routes: Routes = [  &#123;    path: &#x27;**&#x27;,  // 重点是这里    component: EmptyComponent  &#125;];@NgModule(&#123;  declarations: [    AppComponent,  ],  imports: [    BrowserModule,    BrowserAnimationsModule,    NgxPlanetModule,  // 同时这里引入了 NgxPlanetModule    RouterModule.forRoot(routes, &#123; useHash: true &#125;),  ],  providers: [],  bootstrap: [AppComponent]&#125;)export class AppModule &#123; &#125;\n3. 注册子应用// src/app/app.component.tsimport &#123; Component, OnInit &#125; from &#x27;@angular/core&#x27;;import &#123; Planet, SwitchModes &#125; from &#x27;@worktile/planet&#x27;;@Component(&#123;  selector: &#x27;app-root&#x27;,  templateUrl: &#x27;./app.component.html&#x27;,  styleUrls: [&#x27;./app.component.less&#x27;]&#125;)export class AppComponent implements OnInit &#123;  get loadingDone() &#123;    return this.planet.loadingDone;  &#125;  constructor(    private planet: Planet  ) &#123; &#125;  ngOnInit() &#123;    this.planet.setOptions(&#123;      switchMode: SwitchModes.coexist,      errorHandler: error =&gt; &#123;        console.error(`Failed to load resource, error:`, error);      &#125;    &#125;);    this.planet.registerApps([      &#123;        name: &#x27;app1&#x27;,        hostParent: &#x27;#app-host-container&#x27;,        routerPathPrefix: &#x27;/app1/&#x27;,        resourcePathPrefix: &#x27;/app1/&#x27;,        preload: true,        scripts: [          &#x27;main.js&#x27;,          &#x27;polyfills.js&#x27;        ],        styles: [          &#x27;styles.css&#x27;        ],        manifest: &#x27;/app1/assets-manifest.json&#x27;      &#125;,      &#123;        name: &#x27;app2&#x27;,        hostParent: &#x27;#app-host-container&#x27;,        hostClass: &#x27;thy-layout&#x27;,        routerPathPrefix: &#x27;/app2/&#x27;,        resourcePathPrefix: &#x27;/app2/&#x27;,        preload: true,        scripts: [          &#x27;main.js&#x27;,          &#x27;polyfills.js&#x27;        ],        styles: [          &#x27;styles.css&#x27;        ],        manifest: &#x27;/app2/assets-manifest.json&#x27;      &#125;    ]);    // start monitor route changes    // get apps to active by current path    // load static resources which contains javascript and css    // bootstrap angular sub app module and show it    this.planet.start();  &#125;&#125;\n4. 配置子应用菜单、容器&lt;!-- src/app/app.component.html --&gt;&lt;nav&gt;  &lt;a [routerLink]=&quot;[&#x27;/app1/test&#x27;]&quot; routerLinkActive=&quot;active&quot;&gt;应用1&lt;/a&gt;  &lt;a [routerLink]=&quot;[&#x27;/app2/test&#x27;]&quot; routerLinkActive=&quot;active&quot;&gt;应用2&lt;/a&gt;&lt;/nav&gt;&lt;router-outlet&gt;&lt;/router-outlet&gt;&lt;div id=&quot;app-host-container&quot;&gt;&lt;/div&gt;&lt;div *ngIf=&quot;!loadingDone&quot;&gt;加载中...&lt;/div&gt;\n5. 配置代理，方便开发// 根目录下新增文件 proxy.conf.js，内容如下：const PROXY_CONFIG = &#123;  &quot;/app1&quot;: &#123;    &quot;target&quot;: &#x27;http://localhost:3000&#x27;,    &quot;secure&quot;: false  &#125;,  &quot;/app2&quot;: &#123;    &quot;target&quot;: &#x27;http://localhost:3100&#x27;,    &quot;secure&quot;: false  &#125;&#125;module.exports = PROXY_CONFIG\n\n三、子应用配置1. 修改程序入口前面提到我们期望子应用在开发时，能够独立运行，所以不能直接使用 @worktile/planet 提供的如下方法：\ndefineApplication(&#x27;app1&#x27;, (portalApp: PlanetPortalApplication) =&gt; &#123;  return platformBrowserDynamic([    &#123;      provide: PlanetPortalApplication,      useValue: portalApp    &#125;  ])    .bootstrapModule(AppModule)    .then(appModule =&gt; &#123;      return appModule;    &#125;)    .catch(error =&gt; &#123;      console.error(error);      return null;    &#125;);&#125;);\n而是重新提供一个 dyBootstrap 方法，在内部通过 window.__POWERED_BY_PLANET__ 判断是否为集成环境。为了方便各子应用使用，将其封装到 projects/frame/public-api 中，具体代码如下：\nimport &#123; Type, CompilerOptions, NgModuleRef &#125; from &quot;@angular/core&quot;import &#123; platformBrowserDynamic &#125; from &quot;@angular/platform-browser-dynamic&quot;import &#123; PlanetPortalApplication, defineApplication &#125; from &quot;@worktile/planet&quot;import &#123; BootstrapOptions &#125; from &quot;@worktile/planet/application/planet-application-ref&quot;/** * 应用启动函数，根据是否为集成环境，决定如何启动应用 * @param appName 应用名称 * @returns  */export const dyBootstrap = (appName: string) =&gt; &#123;  return &#123;    bootstrapModule&lt;M&gt;(moduleType: Type&lt;M&gt;, compilerOptions?: (CompilerOptions &amp; BootstrapOptions) | Array&lt;CompilerOptions &amp; BootstrapOptions&gt;): Promise&lt;NgModuleRef&lt;M&gt;&gt; &#123;      return new Promise((resolve, reject) =&gt; &#123;        if ((window as any).__POWERED_BY_PLANET__) &#123;          return defineApplication(appName, &#123;            template: `&lt;app-$&#123;appName&#125;&gt;&lt;/app-$&#123;appName&#125;&gt;`,            bootstrap: (portalApp: PlanetPortalApplication) =&gt; &#123;              return platformBrowserDynamic([                &#123;                  provide: PlanetPortalApplication,                  useValue: portalApp                &#125;              ]).bootstrapModule(moduleType, compilerOptions)            &#125;          &#125;)        &#125;        else &#123;          return platformBrowserDynamic().bootstrapModule(moduleType, compilerOptions)        &#125;      &#125;)    &#125;  &#125;&#125;\n那么子应用的启动函数就变成了：\n// projects/app1/src/main.tsimport &#123; dyBootstrap &#125; from &#x27;projects/frame/public-api&#x27;;// 将platformBrowserDynamic().bootstrapModule(AppModule)  .catch(err =&gt; console.error(err));// 改为dyBootstrap(&#x27;app1&#x27;).bootstrapModule(AppModule)  .catch(err =&gt; console.error(err));\n2. 修改打包配置添加自定义 webpack 文件\n// 根目录下新增文件 extr-webpack.config.js，内容如下：const WebpackAssetsManifest = require(&#x27;webpack-assets-manifest&#x27;);module.exports = &#123;    optimization: &#123;        runtimeChunk: false    &#125;,    plugins: [new WebpackAssetsManifest()]&#125;;\n修改 angular.json\n// angular.json&quot;build&quot;: &#123;  &quot;builder&quot;: &quot;@angular-builders/custom-webpack:browser&quot;,  &quot;options&quot;: &#123;    &quot;customWebpackConfig&quot;: &#123;      &quot;path&quot;: &quot;./extra-webpack.config.js&quot;,      &quot;mergeStrategies&quot;: &#123;        &quot;externals&quot;: &quot;replace&quot;,        &quot;module.rules&quot;: &quot;append&quot;      &#125;    &#125;,    &quot;baseHref&quot;: &quot;/app1/&quot;,    &quot;deployUrl&quot;: &quot;/app1/&quot;,    ...  &#125;,  &quot;configurations&quot;: &#123;    ...    &quot;development&quot;: &#123;      ...      &quot;vendorChunk&quot;: false,      ...    &#125;  &#125;&#125;,&quot;serve&quot;: &#123;  &quot;builder&quot;: &quot;@angular-builders/custom-webpack:dev-server&quot;,  ...&#125;\n3. 修改一级模块// projects/app1/src/index.html// 将&lt;app-root&gt;&lt;/app-root&gt;// 改为&lt;app-app1&gt;&lt;/app-app1&gt;// projects/app1/src/app/app.component.ts// 将selector: &#x27;app-root&#x27;,// 改为selector: &#x27;app-app1&#x27;,// projects/app1/src/app/app.component.html// 只保留&lt;router-outlet&gt;&lt;/router-outlet&gt;// 即可\n4. 添加一级路由// projects/app1/src/app/app.module.tsimport &#123; NgModule &#125; from &#x27;@angular/core&#x27;;import &#123; BrowserModule &#125; from &#x27;@angular/platform-browser&#x27;;import &#123; HttpClientModule &#125; from &#x27;@angular/common/http&#x27;;import &#123; BrowserAnimationsModule &#125; from &quot;@angular/platform-browser/animations&quot;;import &#123; RouterModule, Routes &#125; from &#x27;@angular/router&#x27;;import &#123; EmptyComponent &#125; from &#x27;@worktile/planet&#x27;;import &#123; NzMessageModule &#125; from &#x27;ng-zorro-antd/message&#x27;;import &#123; BasicComponent, BasicModule &#125; from &#x27;projects/frame/public-api&#x27;;import &#123; AppComponent &#125; from &#x27;./app.component&#x27;;const routes: Routes = [  &#123;    path: &#x27;&#x27;,    redirectTo: &#x27;app1&#x27;,    pathMatch: &#x27;full&#x27;  &#125;,  &#123;    path: &#x27;app1&#x27;,    component: BasicComponent,  // BasicComponent 是一个基础组件，包含导航栏和侧边栏，和 dyBootstrap 一样，为了方便各子应用使用，将其封装到 `projects/frame/public-api` 中                                // 内部实现了 根据 window.__POWERED_BY_PLANET__ 判断是否是集成环境，如果是，则不显示导航菜单    children: [      &#123;        path: &#x27;test&#x27;,        loadChildren: () =&gt; import(&#x27;./test/test.module&#x27;).then(m =&gt; m.TestModule),        data: &#123; firstMenu: true, alias: &#x27;测试&#x27; &#125;  // 为了方便子应用开发，这里将路由对应的菜单信息直接写在路由配置中，由 `projects/frame/public-api` 提供方法解析路由配置，生成菜单      &#125;    ]  &#125;,  &#123;    path: &#x27;**&#x27;,    component: EmptyComponent  &#125;,]@NgModule(&#123;  declarations: [    AppComponent,  ],  imports: [    BrowserModule,    BrowserAnimationsModule,    HttpClientModule,    BasicModule,    NzMessageModule,    RouterModule.forRoot(routes, &#123; useHash: true &#125;)  ],  providers: [],  bootstrap: [AppComponent]&#125;)export class AppModule &#123; &#125;\n// basic.component.tsimport &#123; Component, OnInit &#125; from &#x27;@angular/core&#x27;;/** * 单应用开发时的基础布局。菜单从Routes中解析而来 */@Component(&#123;  selector: &#x27;dy-basic&#x27;,  templateUrl: &#x27;./basic.component.html&#x27;,  styleUrls: [&#x27;./basic.component.less&#x27;]&#125;)export class BasicComponent &#123;  multiApp = (window as any).__POWERED_BY_PLANET__;&#125;// basic.component.html&lt;router-outlet *ngIf=&quot;multiApp; else devTemp&quot;&gt;&lt;/router-outlet&gt;&lt;ng-template #devTemp&gt;  &lt;div class=&quot;layout pr&quot;&gt;    &lt;div class=&quot;header&quot;&gt;这里是导航栏&lt;/div&gt;        &lt;div class=&quot;layout fdr container pr&quot;&gt;      &lt;div class=&quot;menu&quot;&gt;这里是侧边栏&lt;/div&gt;      &lt;div class=&quot;layout&quot;&gt;        &lt;router-outlet&gt;&lt;/router-outlet&gt;      &lt;/div&gt;    &lt;/div&gt;      &lt;/div&gt;&lt;/ng-template&gt;\n\n四、修改启动脚本// package.json&quot;scripts&quot;: &#123;  &quot;ng&quot;: &quot;ng&quot;,  &quot;start&quot;: &quot;ng serve --proxy-config proxy.config.js&quot;,  &quot;start1&quot;: &quot;ng serve app1 --port 3000&quot;,  &quot;start2&quot;: &quot;ng serve app2 --port 3100&quot;&#125;,\n之后就可以通过 npm run start 启动主应用，npm run start1 启动子应用1，npm run start2 启动子应用2 进行测试了。\n","categories":["Angular"],"tags":["微前端","worktile/planet"]},{"title":"yalc:最好用的前端link调试方案","url":"/2024/04/08/%E6%9C%80%E5%A5%BD%E7%94%A8%E7%9A%84%E5%89%8D%E7%AB%AFlink%E8%B0%83%E8%AF%95%E6%96%B9%E6%A1%88/","content":"一、什么是yalc对包开发者而言，一种比yarn/npm link更好的开发流程。它的主要对标者就是yarn/npm link，它主要解决了一些yarn/npm link本身存在的缺陷，满足了包开发者的实际需求。\n二、yalc的安装npm i yalc -g# oryarn global add yalc\n三、yalc的基本使用1. yalc publish (发布依赖)在已经构建完成的包(比如good-ui)中执行\nyalc publish\n在yalc publish后，它会逐一执行npm生命周期脚本，如：prepublish、prepare、prepublishOnly、prepack…等。同时，你也可以通过--no-script禁用钩子钩动各种脚本。\n2. yalc add (添加依赖)在目标包(比如admin-management)中执行：\nyalc add good-ui\n\n现在，你可以在项目中通过\nimport &#123; Button &#125; from &#x27;good-ui&#x27;;\n\n用到你本地good-ui中的最新代码了！而且！admin-management&#x2F;node_modules中原本依赖的good-ui文件也并没有丢，它们被放到了一个缓存文件中，你可以轻松还原，如下：\n3. yalc remove (移除依赖)在admin-management项目中执行：\nyalc remove good-ui\n\n嘿！我又重新用上了node_modules中原本依赖的good-ui，而且快如闪电！太完美了！\n4. yalc push (更新和推送)没有人能做到一次成功！如果在你修改了good-ui里的一些代码，你只需要执行：\nyalc publish --push# 简化为：yalc push\n\n你的最新的包，直接在admin-management中生效了！甚至能触发了HRM！\n四、其他需要注意的是，yalc会把包发布到~/.yalc/packages中，如果必要的话，需要定时清理，以免占用过多磁盘空间。\n","categories":["工具"],"tags":["yalc"]},{"title":"极空间Docker安装CentOS并开启SSH","url":"/2024/10/12/%E6%9E%81%E7%A9%BA%E9%97%B4Docker%E5%AE%89%E8%A3%85CentOS%E5%B9%B6%E5%BC%80%E5%90%AFSSH/","content":"前言购买极空间的目的，一方面是为了方便存储、共享照片、视频、音乐，尤其是宝宝照片，换下来的旧手机、iPad，照片都没有统一的存储位置。iCloud？空间不够。百度网盘？空间方面，应该是之前参加活动，达到了1T，还可以，但下载速度实在是太恶心。而且毕竟是托管到了第三方平台，虽然百度是一家大型互联网公司，但以后谁说得准呢，想当年诺基亚也是响当当的手机厂商，不一样折戟沉沙。\n另一方面，利用极空间的Docker可以搭建一台专属服务器，平时搞个测试、部署个Web服务，实在是太方便了。之前尝试过在家里弄了台主机作为服务器，也购买过阿里云的服务器，但一方面不支持移动端、不方便共享，满足不了上面共享照片的需求，另一方面云服务器费用太高，最终都放弃了。\n虽然极空间依赖他的App，但内容是存储到自己硬盘里的，即便将来他也成为了诺基亚，理论上只要已安装的App还在，就能使用。再退一步，还可以将硬盘取出来直连接到电脑获取内容。\n1. 安装CentOS1.1 下载镜像直接在常用镜像里搜索CentOS下载即可。\n1.2 安装镜像双击下载好的镜像，开始配置。极空间的参数设置窗口分8个Tab。我们这里主要设置“基本设置”、“文件夹路径”、“端口”这三个Tab，其余页面保持默认就可以了。\n基本设置由于我的极空间是8核16G的，所以这里我就不启用性能限制了。\n文件夹路径这里可以这么理解：将CentOS的/data目录映射到极空间的/SATA0/centos目录，这样在CentOS里就可以通过/data目录访问到极空间/SATA0/centos目录下的内容。\n端口其实就是做一个端口映射，将极空间的某个端口映射到CentOS的某个端口。这里需要一次性尽量设置多一些，因为后面再编辑的话，它会初始化CentOS，导致之前安装的软件都丢失，不过放到/data(映射到极空间目录)的内容不会丢失。\n2. 安装Linux常备组件首先从极空间Docker官方SSH进入系统，进行设置。进入之后是默认root账户。\n安装镜像源和系统下载工具下面的命令需要整体复制粘贴，应该是极空间中Docker的命令行工具有bug\nsed -i -e &quot;s|#baseurl=http://mirror.centos.org|baseurl=http://vault.centos.org|g&quot; /etc/yum.repos.d/CentOS-* yum install -y wget\n\n安装网络工具\nyum install -y openssh*yum install -y net-tools\n\n安装密码工具\nyum install -y passwd\n\n修改密码\npasswd root\n\n3. 开启SSH修改ssh设置首先对系统的ssh设置进行修改（ssh工具就是上文中安装的openssh）。\nvi /etc/ssh/sshd_config\n\n\n使能ssh在正常的使能方法里，直接使用Linux的systemctl工具就可以使能。但是，该工具是需要docker系统的privilege权限的，而且需要在开启docker的时候就赋予权限。而极空间既没有开放命令行操作，也没有开放privilege权限，所以我们也就无法使用命令行在docker开启的时候赋予privilege权限了。因此，我们必须使用其他的方法进行使能。请按照下面方法进行配置：\nmkdir -p /var/run/sshdssh-keygen -q -t rsa -b 2048 -f /etc/ssh/ssh_host_rsa_key -N &#x27;&#x27; ssh-keygen -q -t ecdsa -f /etc/ssh/ssh_host_ecdsa_key -N &#x27;&#x27;ssh-keygen -t dsa -f /etc/ssh/ssh_host_ed25519_key -N &#x27;&#x27;/usr/sbin/sshd -D &amp; \n然后就可以开启ssh工具了。如果需要确认是否已经开启，可以输入下述指令：\nnetstat -antup | grep sshd\n应该会有以下输出\ntcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      256/sshdtcp6       0      0 :::22                   :::*                    LISTEN      256/sshd\n\n4. 使用SSH工具连接现在就可以使用比如Termius等ssh工具进行连接了。\n5. 配置ll命令在CentOS中，ll命令是ls -l的别名，但是默认情况下，CentOS并没有配置ll命令。因此，我们需要手动配置一下。\nvi ~/.bashrc\n在文件末尾添加以下内容：\nalias ll=&#x27;ls -alF&#x27;\n然后保存并退出，使用以下命令使配置生效：\nsource ~/.bashrc","categories":["极空间"]},{"title":"电子表格组件调研","url":"/2024/11/27/%E7%94%B5%E5%AD%90%E8%A1%A8%E6%A0%BC%E7%BB%84%E4%BB%B6%E8%B0%83%E7%A0%94/","content":"\n\n\n名称\n介绍\n是否开源\n备注\n\n\n\n\nx-sheet\n高性能 web javaScript 电子表格从Demo来看，bug较多，多个 sheet 时内容没有隔离开，统计函数不生效等\nMPL-2.0\nStar 145\n\n\nX-Spreadsheet\n这是一个基于 Web(es6) canvas 构建的轻量级 Excel 开发库Demo中没有纵向滚动条，这对于一个 Excel 组件来说，不是一个很好的体验\nMIT\nStar 14.2k\n\n\nFortuneSheet\nFortuneSheet 是一款开箱即用的类似 Excel 和 Google Sheets 的 javascript 表格组件。本项目源于 Luckysheet（已经停更），并继承了它的很多代码。我们为将其转换为 typescript 做了很多努力，并且解决了一些项目层面的问题。另外据网友总结，在研究和使用它的时候还是发现了很多问题，比如在 next 项目中无法更新和初始化数据，同时对图片的支持也不是特别友好。\nMIT\n支持 ReactStar 2.6k\n\n\nUniver\nUniver 提供了一个全面的企业级文档与数据协同的解决方案，支持电子表格、文本文档和演示幻灯片三大核心文档类型。通过灵活的 API 和插件机制，开发者可以在 Univer 的基础上进行个性化功能的定制和扩展，以适应不同用户在不同场景下的特定需求。Univer 其实就是由 Luckysheet 3.x 更名而来。\nApache-2.0 license基础功能免费使用\nStar 7.5k\n\n\nHandsontable\nHandsontable 是一款完全开源的在线电子表格组件，他提供了详细的文档和丰富的API接口来保证我们能实现专业级电子表格。同时支持多种前端框架，Vue2、Vue3、React、Angular 等，非常适合有技术余力的团队进行二次开发。\n查看License\n英文文档Star 20.1k\n\n\nSpreadJS\n专业的在线 Excel，纯前端表格控件，功能布局与 Excel 高度类似\n不开源\n\n\n\n","tags":["电子表格"]},{"title":"第一个基于Electron的小工具Stock","url":"/2024/12/27/%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%9F%BA%E4%BA%8EElectron%E7%9A%84%E5%B0%8F%E5%B7%A5%E5%85%B7Stock/","content":"起因对于上班族来说，怎么能够更隐蔽的盯盘而不被领导发现呢？那自然是所占屏幕的空间越小越好了。像我这种门外汉，其实不需要太多的功能，只需要能够实时查看股票的最新价格、涨跌情况即可，最好是能够随时一眼就能看到的。\n其它工具\nMac自带的[股市]，可以添加到通知栏，但缺点也很明显，每次查看都需要点开通知栏，而且刷新频率太低，不满足实时监控的需求。\n股票菜单栏，这个工具可在系统菜单栏实时显示股票行情信息，是个很不错的选择，但需要付费，好在不贵，¥38。\nStockBar，相比上一个工具，这个工具只是在菜单栏显示了个图标，还得点击才能查看，有点麻烦，而且也要付费，¥28。\nVS Code 插件 Stock Bar，这个工具其实很不错，可以在 VS Code 的状态栏实时显示股票行情信息，但正如其名，必须打开 VS Code 才能使用。\n\n\n\n程序员的自我修养没一个满意的，作为一名程序员，这怎么能忍？于是乎，我决定自己动手，写个和 股票菜单栏 功能类似的工具。\n不过我并没有接触过 Swift 和 Objective-C，只是之前听说过使用 Electron 可以开发跨平台桌面应用，所以那就研究一下 Electron 吧。\nElectron\n中文网站\nElectron + Vue3 开发跨平台桌面应用【从项目搭建到打包完整过程】\n\n如果出现安装 Electron 失败的情况，可以尝试使用下面的镜像：\n# 1、打开npm的配置文件npm config edit# 2、在打开的配置文件空白处将下面几个配置添加上去，注意如果有原有的这几项配置，就修改registry=https://registry.npmmirror.comelectron_mirror=https://cdn.npmmirror.com/binaries/electron/electron_builder_binaries_mirror=https://npmmirror.com/mirrors/electron-builder-binaries/\n\n而想要将内容显示在菜单栏，则需要用到 Electron Tray。Tray 可以在菜单栏显示一个图标，也可以显示文字，就像这样：\nlet trayapp.whenReady().then(() =&gt; &#123;  const icon = nativeImage.createFromPath(&#x27;path/to/asset.png&#x27;)  tray = new Tray(icon)  tray.setTitle(&#x27;Hello World&#x27;)&#125;)\n\n通过上面这种方式显示到菜单栏的文字，是白色的，不能自定义颜色，这当然不符合我们的需求，股票的涨跌肯定是要用不同颜色表示的嘛。\n既然 Tray 是将一个 png 图标显示到菜单栏的，那我们能否通过 Canvas 生成一个 png 然后显示到菜单栏呢？如果可以的话，那就可以使用 Canvas 绘制任意的文字了。\n通过 Electron 执行 javascript 创建 Tray 并显示到菜单栏，这个过程其实是没有浏览器环境的，window 和 document 对象都是不存在的，所以不能直接使用 Canvas，需要使用 node-canvas。\nnode-canvasnode-canvas 是在 Node.js 上的一套 Canvas 实现，它提供了跟浏览器中 Canvas 几乎一致的接口。\n如果安装 canvas 报错，可以参考这里：详细记录一次npm i canvas报错的解决过程，我只遇到了 pkg-config: command not found 这一个错误，还比较幸运。\n接下来就是绘制内容的代码了：\nfunction createImage(text, color) &#123;  text = text || &#x27;&#x27;  color = color || &#x27;#fff&#x27;  if (!cvs) &#123;    cvs = createCanvas(144, 48)    ctx = cvs.getContext(&#x27;2d&#x27;)    ctx.font = &#x27;15px Arial&#x27;    ctx.textAlign = &#x27;center&#x27;    ctx.textBaseline = &#x27;middle&#x27;  &#125;  ctx.clearRect(0, 0, cvs.width, cvs.height)  ctx.fillStyle = color  ctx.fillText(text, cvs.width / 2, cvs.height / 2 + 1)  return nativeImage.createFromDataURL(cvs.toDataURL(&#x27;image/png&#x27;, 1.0))&#125;let trayapp.whenReady().then(() =&gt; &#123;  tray = new Tray(createImage(&#x27;Hello World&#x27;, &#x27;#fff&#x27;))&#125;)\n\n获取股票数据进行到这里，还有一个关键问题，就是从哪能获取到股票数据呢？我选择了 新浪股票。\n如何获取新浪财经的股票实时数据\n遗留问题\n使用 Canvas 绘制的图片显示到菜单栏之后，文字比较模糊，和将其作为纹理显示到 Threejs 中是一样的，但是因为没有浏览器环境，所以常规的抗锯齿、通过 style 放大尺寸等方法都不好使，不知道有没有什么好的解决方案。\n使用 Electron 构建之后的程序包也太大了点，就这么一个小工具，不使用 node-canvas 的情况下，有 180 多 MB，使用 node-canvas 之后，有 200 多 MB，这着实有点过分了。\n\n","categories":["Electron"],"tags":["Electron","node-canvas"]},{"title":"聚类分析使用场景","url":"/2023/07/12/%E8%81%9A%E7%B1%BB%E5%88%86%E6%9E%90%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/","content":"一、数据集\n公司积累了一批员工应用的使用数据，要根据不同维度划分不同的员工群体。如经常访问招聘网站和网络邮件的员工可能会有离职倾向，这类群体需要重点关注。\n该数据集中含有员工访问CRM、云盘、招聘等特征信息。\n\n二、数据预处理\n想通过CRM、云盘、招聘、网络邮件划分群体，选择这几个字段。\n由于不同字段数值差别大，进行标准化处理。\n处理后的数据如下\n\n三、聚类\n选择聚类算法这里默认选择k-means算法\n选择聚类字段\n选择要分成几类\n\n四、可视化展示\n选择纬度选择2维\n选择邮件为X轴，招聘网站为Y轴。可以看到访问招聘网站较多的同时访问邮件也较多的人比较集中。也说明这使用这几个参数进行分类效果较好。\n选择CRM为X轴，云盘为Y轴。可以看到比较分散，说明这两个分类效果较差。\n\n","categories":["其他"]},{"title":"通过Gitee的OpenAPI实现图床","url":"/2024/09/27/%E9%80%9A%E8%BF%87Gitee%E7%9A%84OpenAPI%E5%AE%9E%E7%8E%B0%E5%9B%BE%E5%BA%8A/","content":"写博客、记笔记时，总会遇到图片上传的问题，如果使用本地图片，那么图片的存储和管理就会变得非常麻烦，所以需要一个图床来存储图片，方便管理和使用。\n自己使用过两款图床 App，这里先说下使用感受。\n1. uPicuPic 是一款非常优秀的图床 App，支持多种图床，包括七牛云、阿里云、腾讯云等，同时也支持自定义图床。uPic 的界面简洁，操作方便，上传速度也很快。但是，在我的macOS Big Sur@11.7.10上配置了 Gitee 图床后，上传图片没反应。我确认配置没有问题，因为同样的配置在 PicGo 上是可以正常上传的。\n2. PicGoPicGo 同样也是一款优秀的开源图床工具，支持多种图床，包括七牛云、阿里云、腾讯云等，同时也支持自定义图床。但是为什么也不使用它呢？因为它的操作比较麻烦，每次上传图片都得打开主窗口，不能在菜单栏直接上传。虽然将图片拖拽到菜单栏上提示可以上传，但松开鼠标没有任何反应。\n\n而且上述两款 App 都不支持对图片进行分类。而使用 Gitee 的 OpenAPI 实现图床，就可以通过目录对图片进行分类，方便管理和使用。\n3. 通过 Gitee 的 OpenAPI 实现图床Gitee 提供了 OpenAPI，可以用来实现图床功能。下面是使用 Gitee OpenAPI 实现图床的步骤：\n\n在 Gitee 上创建一个公开的仓库，用于存储图片。\n获取 Gitee 的 Access Token，用于身份验证。\n使用 Gitee OpenAPI 上传图片到仓库中。通过新建文件 https://gitee.com/api/v5/repos/&#123;owner&#125;/&#123;repo&#125;/contents/&#123;path&#125; API，实现图片上传。\n使用 Gitee OpenAPI 获取图片的 URL，用于在博客或笔记中使用。通过获取仓库具体路径下的内容 https://gitee.com/api/v5/repos/&#123;owner&#125;/&#123;repo&#125;/contents(/&#123;path&#125;) API 递归读取仓库目录，过滤出图片，并展示到界面。\n\n\n支持直接点击名称复制 Markdown 格式的图片链接 ![图片名称](图片链接)，也可以按住 Shift 键点击名称复制 img 标签格式的图片链接 &lt;img width=&quot;500&quot; alt=&quot;图片名称&quot; src=&quot;图片链接&quot;&gt;，也可以按住 Alt 键点击名称只复制图片链接。\n支持剪贴板上传，将图片复制到剪贴板，直接 ctrl + v 即可将图片上传到 Gitee 仓库中。\n\n","categories":["工具"],"tags":["图床"]},{"title":"阿里云-智能语音交互","url":"/2025/01/06/%E9%98%BF%E9%87%8C%E4%BA%91-%E6%99%BA%E8%83%BD%E8%AF%AD%E9%9F%B3%E4%BA%A4%E4%BA%92/","content":"随着智能家居、移动设备及车载信息系统等领域中智能语音助手应用的日益普及，我们不妨思考：Web端管理平台能否也实现类似功能呢？可以肯定的是，这在技术上是完全可以实现的；至于是否好用、能否得到客户认可，那就是另外一个问题了。而提到语音助手，语音识别则是其中的关键技术之一。本文主要介绍如何使用阿里云的智能语音交互服务，实现实时语音识别功能。\n开通服务要使用阿里云的智能语音交互服务，首先需要开通服务。\n进入 智能语音交互产品首页，单击“开通并购买”即可开通智能语音交互服务。阿里云提供3个月的免费试用，对于测试来说已经足够了。\nRAM用户在接入阿里云之前，我们先来了解一下RAM用户。这是官方文档中的定义和使用流程，我们可以简单理解为他是阿里云账号或其他RAM用户的子账号，并且阿里云强烈建议开发者使用RAM用户来登录控制台、调用API。\n创建用户在 RAM访问控制&#x2F;用户 控制台这里创建好用户，并在用户详情页面，创建该用户的 AccessKey。创建好之后，保存好 AccessKey ID 和 AccessKey Secret，后面会用到。\n关于 AccessKey ID 和 AccessKey Secret 的说明，官方文档 中有详细的说明，这里不再赘述。\n分配权限另外记得给该用户分配相应的权限，这里只需要授予AliyunNLSFullAccess的权限即可。\n创建项目接下来我们就可以进入 智能语音交互 控制台创建一个测试项目了，有些平台叫做“应用”，这里叫做“项目”，其实都是一个意思。主要是用来区分一个具体的项目、产品或服务。平台可以通过应用来监控和限制API请求的数量，以防止滥用；另外还能够基于单个应用收集数据，帮助开发者了解它们的使用情况和性能表现。\n这一步我们会得到一个 Appkey，主要用来区分不同的应用，正如上面所说，如果不加以区分，平台是无法知道是哪个应用在调用API的，也就无法进行数据的统计分析。\n获取Token其实在上面有了 AccessKey ID 和 AccessKey Secret 之后就可以获取 Token 了，甚至都不需要 AccessKey ID 和 AccessKey Secret 也能获取 Token，因为阿里云贴心的提供了获取临时 AccessToken 的方式：\n如果想通过代码获取 Token 的话，阿里云提供了3种获取 Token 的方式，详见官方文档。\n开发代码了解这几个步骤、流程之后，就可以着手开发代码了。这里已经有一位兄弟实现了vue + websocket接入阿里云实时语音识别，代码完全可用，我就不重复造轮子了。\n这里是 WebSocket 接入的官方文档。\n源码https://github.com/DoAutumn/aliyun-audio\n","categories":["其他"],"tags":["实时语音识别"]}]